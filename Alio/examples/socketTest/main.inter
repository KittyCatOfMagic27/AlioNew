proc SYS_write ; 
in def i32 ?fd ; 
in def i64 ?buffer ; 
in def i32 ?size ; 
out def i32 ?write_amount ; 
begin ; 
?write_amount = syscall ( 1 ?fd ?buffer ?size ) ; 
end SYS_write ; 
proc SYS_read ; 
in def i32 ?fd ; 
in def i64 ?buffer ; 
in def i32 ?size ; 
out def i32 ?read_amount ; 
begin ; 
?read_amount = syscall ( 0 ?fd ?buffer ?size ) ; 
end SYS_read ; 
proc SYS_openfd ; 
in def i64 ?filename ; 
in def i32 ?flags ; 
in def i32 ?mode ; 
out def i32 ?fd ; 
begin ; 
?fd = syscall ( 2 ?filename ?flags ?mode ) ; 
end SYS_openfd ; 
proc SYS_closefd ; 
in def i32 ?fd ; 
begin ; 
syscall ( 3 ?fd ) ; 
end SYS_closefd ; 
proc SYS_fstat ; 
in def i32 ?fd ; 
in def i64 ?fstat_struct ; 
begin ; 
syscall ( 5 ?fd ?fstat_struct ) ; 
end SYS_fstat ; 
proc SYS_exit ; 
in def i32 ?error_code ; 
begin ; 
syscall ( 60 ?error_code ) ; 
end SYS_exit ; 
proc sizeof_file ; 
in def i32 ?fd ; 
out def i32 ?size ; 
begin ; 
def i1152 ?fstat_struct ; 
def i64 ?y = & ?fstat_struct ; 
call SYS_fstat ( ?fd ?y ) ; 
?y = + i64 i32 ?y 48 ; 
?size = @ ?y ; 
end sizeof_file ; 
proc printu ; 
in def i32 ?fd ; 
in def i32 ?x ; 
begin ; 
call __asm ( ; 
"  mov    eax, edi" ; 
"  mov    ecx, 10" ; 
"  push   rcx" ; 
"  mov    rsi, rsp" ; 
"  sub    rsp, 16" ; 
".toascii_digit:" ; 
"  xor    edx, edx" ; 
"  div    ecx" ; 
"  add    edx, 48" ; 
"  dec    rsi" ; 
"  mov    [rsi], dl" ; 
"  test   eax,eax" ; 
"  jnz  .toascii_digit" ; 
"  mov    eax, 1" ; 
"  lea    edi, [rsp+16]" ; 
"  sub    edi, esi" ; 
"  mov    rax, rsi" ; 
"  mov    esi, edi" ; 
"  mov    rdi, rax" ; 
"  mov    eax, dword [rbp-4]" ; 
) ; 
call SYS_write ( ) ; 
call __asm ( "  add rsp, 24" ) ; 
end printu ; 
proc printi ; 
in def i32 ?fd ; 
in def i32 ?x ; 
out def i32 ?err ; 
begin ; 
jmpc .if1 ! < i32 i32 ?x 4294967294 ; 
?x = - i32 i32 4294967294 ?x ; 
?x = + i32 i32 ?x 2 ; 
def i8 ?y = "-" ; 
def i64 ?z = & ?y ; 
call SYS_write ( ?fd ?z 1 ) ; 
label .if1 ; 
?err = call printu ( ?fd ?x ) ; 
end printi ; 
proc printc ; 
in def i32 ?fd ; 
in def i8 ?x ; 
out def i32 ?err ; 
begin ; 
def i64 ?y = & ?x ; 
?err = call SYS_write ( ?fd ?y 1 ) ; 
end printc ; 
proc strlen ; 
in def i64 ?str ; 
out def i32 ?len ; 
begin ; 
def i64 ?beginning = ?str ; 
def i8 ?c = @ ?str ; 
jmp .whilecmp1 ; 
label .while1 ; 
++ ?str ; 
?c = @ ?str ; 
label .whilecmp1 ; 
jmpc .while1 ?c ; 
?len = - i64 i64 ?str ?beginning ; 
end strlen ; 
proc strcmp_speclens ; 
in def i64 ?str1 ; 
in def i32 ?len1 ; 
in def i64 ?str2 ; 
in def i32 ?len2 ; 
out def i8 ?equals? ; 
begin ; 
?equals? = == i32 i32 ?len1 ?len2 ; 
jmpc .if2 ! ?equals? ; 
def i8 ?continue = true ; 
def i8 ?i = 0 ; 
jmp .whilecmp2 ; 
label .while2 ; 
def i8 ?c1 = @ ?str1 ; 
def i8 ?c2 = @ ?str2 ; 
?equals? = == i8 i8 ?c1 ?c2 ; 
def i8 ?nend = < i8 i32 ?i ?len1 ; 
?continue = && i8 i8 ?equals? ?nend ; 
++ ?i ; 
++ ?str1 ; 
++ ?str2 ; 
label .whilecmp2 ; 
jmpc .while2 ?continue ; 
label .if2 ; 
end strcmp_speclens ; 
proc prints ; 
in def i32 ?fd ; 
in def i64 ?str ; 
out def i32 ?err ; 
begin ; 
def i32 ?len = call strlen ( ?str ) ; 
?err = call SYS_write ( ?fd ?str ?len ) ; 
end prints ; 
proc __print_error ; 
in def i32 ?error ; 
begin ; 
?error = - i32 i32 4294967294 ?error ; 
?error = + i32 i32 ?error 2 ; 
def i2048 ?error_msg ; 
def i64 ?eptr = & ?error_msg ; 
def i64 ?null = 0 ; 
def i32 ?i = 0 ; 
jmp .whilecmp3 ; 
label .while3 ; 
@ ?eptr i64 ?null ; 
?eptr = + i64 i32 ?eptr 8 ; 
?i = + i32 i32 ?i 8 ; 
label .whilecmp3 ; 
jmpc .while3 < i32 i32 ?i 256 ; 
?eptr = & ?error_msg ; 
jmpc .if3 ! == i32 i32 ?error 1 ; 
?error_msg = "Operation not permitted." ; 
jmp .escape4 ; 
label .if3 ; 
jmpc .elif1 ! == i32 i32 ?error 2 ; 
?error_msg = "No such file or directory." ; 
jmp .escape4 ; 
label .elif1 ; 
jmpc .elif2 ! == i32 i32 ?error 3 ; 
?error_msg = "No such process." ; 
jmp .escape4 ; 
label .elif2 ; 
jmpc .elif3 ! == i32 i32 ?error 4 ; 
?error_msg = "Interrupted system call." ; 
jmp .escape4 ; 
label .elif3 ; 
jmpc .elif4 ! == i32 i32 ?error 5 ; 
?error_msg = "I/O error." ; 
jmp .escape4 ; 
label .elif4 ; 
jmpc .elif5 ! == i32 i32 ?error 6 ; 
?error_msg = "No such device or address." ; 
jmp .escape4 ; 
label .elif5 ; 
jmpc .elif6 ! == i32 i32 ?error 7 ; 
?error_msg = "Argument list too long." ; 
jmp .escape4 ; 
label .elif6 ; 
jmpc .elif7 ! == i32 i32 ?error 8 ; 
?error_msg = "Exec format error." ; 
jmp .escape4 ; 
label .elif7 ; 
jmpc .elif8 ! == i32 i32 ?error 9 ; 
?error_msg = "Bad file number." ; 
jmp .escape4 ; 
label .elif8 ; 
jmpc .elif9 ! == i32 i32 ?error 10 ; 
?error_msg = "No child processes." ; 
jmp .escape4 ; 
label .elif9 ; 
jmpc .elif10 ! == i32 i32 ?error 11 ; 
?error_msg = "Try again." ; 
jmp .escape4 ; 
label .elif10 ; 
jmpc .elif11 ! == i32 i32 ?error 12 ; 
?error_msg = "Out of memory." ; 
jmp .escape4 ; 
label .elif11 ; 
jmpc .elif12 ! == i32 i32 ?error 13 ; 
?error_msg = "Permission denied." ; 
jmp .escape4 ; 
label .elif12 ; 
jmpc .elif13 ! == i32 i32 ?error 14 ; 
?error_msg = "Bad address." ; 
jmp .escape4 ; 
label .elif13 ; 
jmpc .elif14 ! == i32 i32 ?error 15 ; 
?error_msg = "Block device required." ; 
jmp .escape4 ; 
label .elif14 ; 
jmpc .elif15 ! == i32 i32 ?error 16 ; 
?error_msg = "Device or resource busy." ; 
jmp .escape4 ; 
label .elif15 ; 
jmpc .elif16 ! == i32 i32 ?error 17 ; 
?error_msg = "File exists." ; 
jmp .escape4 ; 
label .elif16 ; 
jmpc .elif17 ! == i32 i32 ?error 18 ; 
?error_msg = "Cross-device link." ; 
jmp .escape4 ; 
label .elif17 ; 
jmpc .elif18 ! == i32 i32 ?error 19 ; 
?error_msg = "No such device." ; 
jmp .escape4 ; 
label .elif18 ; 
jmpc .elif19 ! == i32 i32 ?error 20 ; 
?error_msg = "Not a directory." ; 
jmp .escape4 ; 
label .elif19 ; 
jmpc .elif20 ! == i32 i32 ?error 21 ; 
?error_msg = "Is a directory." ; 
jmp .escape4 ; 
label .elif20 ; 
jmpc .elif21 ! == i32 i32 ?error 22 ; 
?error_msg = "Invalid argument." ; 
jmp .escape4 ; 
label .elif21 ; 
jmpc .elif22 ! == i32 i32 ?error 23 ; 
?error_msg = "File table overflow." ; 
jmp .escape4 ; 
label .elif22 ; 
jmpc .elif23 ! == i32 i32 ?error 24 ; 
?error_msg = "Too many open files." ; 
jmp .escape4 ; 
label .elif23 ; 
jmpc .elif24 ! == i32 i32 ?error 25 ; 
?error_msg = "Not a typewriter." ; 
jmp .escape4 ; 
label .elif24 ; 
jmpc .elif25 ! == i32 i32 ?error 26 ; 
?error_msg = "Text file busy." ; 
jmp .escape4 ; 
label .elif25 ; 
jmpc .elif26 ! == i32 i32 ?error 27 ; 
?error_msg = "File too large." ; 
jmp .escape4 ; 
label .elif26 ; 
jmpc .elif27 ! == i32 i32 ?error 28 ; 
?error_msg = "No space left on device." ; 
jmp .escape4 ; 
label .elif27 ; 
jmpc .elif28 ! == i32 i32 ?error 29 ; 
?error_msg = "Illegal seek." ; 
jmp .escape4 ; 
label .elif28 ; 
jmpc .elif29 ! == i32 i32 ?error 30 ; 
?error_msg = "Read-only file system." ; 
jmp .escape4 ; 
label .elif29 ; 
jmpc .elif30 ! == i32 i32 ?error 31 ; 
?error_msg = "Too many links." ; 
jmp .escape4 ; 
label .elif30 ; 
jmpc .elif31 ! == i32 i32 ?error 32 ; 
?error_msg = "Broken pipe." ; 
jmp .escape4 ; 
label .elif31 ; 
jmpc .elif32 ! == i32 i32 ?error 33 ; 
?error_msg = "Math argument out of domain of func." ; 
jmp .escape4 ; 
label .elif32 ; 
jmpc .elif33 ! == i32 i32 ?error 34 ; 
?error_msg = "Math result not representable." ; 
jmp .escape4 ; 
label .elif33 ; 
jmpc .elif34 ! == i32 i32 ?error 35 ; 
?error_msg = "Resource deadlock would occur." ; 
jmp .escape4 ; 
label .elif34 ; 
jmpc .elif35 ! == i32 i32 ?error 36 ; 
?error_msg = "File name too long." ; 
jmp .escape4 ; 
label .elif35 ; 
jmpc .elif36 ! == i32 i32 ?error 37 ; 
?error_msg = "No record locks available." ; 
jmp .escape4 ; 
label .elif36 ; 
jmpc .elif37 ! == i32 i32 ?error 38 ; 
?error_msg = "Function not implemented." ; 
jmp .escape4 ; 
label .elif37 ; 
jmpc .elif38 ! == i32 i32 ?error 39 ; 
?error_msg = "Directory not empty." ; 
jmp .escape4 ; 
label .elif38 ; 
jmpc .elif39 ! == i32 i32 ?error 40 ; 
?error_msg = "Too many symbolic links encountered." ; 
jmp .escape4 ; 
label .elif39 ; 
jmpc .elif40 ! == i32 i32 ?error 42 ; 
?error_msg = "No message of desired type." ; 
jmp .escape4 ; 
label .elif40 ; 
jmpc .elif41 ! == i32 i32 ?error 43 ; 
?error_msg = "Identifier removed." ; 
jmp .escape4 ; 
label .elif41 ; 
jmpc .elif42 ! == i32 i32 ?error 44 ; 
?error_msg = "Channel number out of range." ; 
jmp .escape4 ; 
label .elif42 ; 
jmpc .elif43 ! == i32 i32 ?error 45 ; 
?error_msg = "Level 2 not synchronized." ; 
jmp .escape4 ; 
label .elif43 ; 
jmpc .elif44 ! == i32 i32 ?error 46 ; 
?error_msg = "Level 3 halted." ; 
jmp .escape4 ; 
label .elif44 ; 
jmpc .elif45 ! == i32 i32 ?error 47 ; 
?error_msg = "Level 3 reset." ; 
jmp .escape4 ; 
label .elif45 ; 
jmpc .elif46 ! == i32 i32 ?error 48 ; 
?error_msg = "Link number out of range." ; 
jmp .escape4 ; 
label .elif46 ; 
jmpc .elif47 ! == i32 i32 ?error 49 ; 
?error_msg = "Protocol driver not attached." ; 
jmp .escape4 ; 
label .elif47 ; 
jmpc .elif48 ! == i32 i32 ?error 50 ; 
?error_msg = "No CSI structure available." ; 
jmp .escape4 ; 
label .elif48 ; 
jmpc .elif49 ! == i32 i32 ?error 51 ; 
?error_msg = "Level 2 halted." ; 
jmp .escape4 ; 
label .elif49 ; 
jmpc .elif50 ! == i32 i32 ?error 52 ; 
?error_msg = "Invalid exchange." ; 
jmp .escape4 ; 
label .elif50 ; 
jmpc .elif51 ! == i32 i32 ?error 53 ; 
?error_msg = "Invalid request descriptor." ; 
jmp .escape4 ; 
label .elif51 ; 
jmpc .elif52 ! == i32 i32 ?error 54 ; 
?error_msg = "Exchange full." ; 
jmp .escape4 ; 
label .elif52 ; 
jmpc .elif53 ! == i32 i32 ?error 55 ; 
?error_msg = "No anode." ; 
jmp .escape4 ; 
label .elif53 ; 
jmpc .elif54 ! == i32 i32 ?error 56 ; 
?error_msg = "Invalid request code." ; 
jmp .escape4 ; 
label .elif54 ; 
jmpc .elif55 ! == i32 i32 ?error 57 ; 
?error_msg = "Invalid slot." ; 
jmp .escape4 ; 
label .elif55 ; 
jmpc .elif56 ! == i32 i32 ?error 59 ; 
?error_msg = "Bad font file format." ; 
jmp .escape4 ; 
label .elif56 ; 
jmpc .elif57 ! == i32 i32 ?error 60 ; 
?error_msg = "Device not a stream." ; 
jmp .escape4 ; 
label .elif57 ; 
jmpc .elif58 ! == i32 i32 ?error 61 ; 
?error_msg = "No data available." ; 
jmp .escape4 ; 
label .elif58 ; 
jmpc .elif59 ! == i32 i32 ?error 62 ; 
?error_msg = "Timer expired." ; 
jmp .escape4 ; 
label .elif59 ; 
jmpc .elif60 ! == i32 i32 ?error 63 ; 
?error_msg = "Out of streams resources." ; 
jmp .escape4 ; 
label .elif60 ; 
jmpc .elif61 ! == i32 i32 ?error 64 ; 
?error_msg = "Machine is not on the network." ; 
jmp .escape4 ; 
label .elif61 ; 
jmpc .elif62 ! == i32 i32 ?error 65 ; 
?error_msg = "Package not installed." ; 
jmp .escape4 ; 
label .elif62 ; 
jmpc .elif63 ! == i32 i32 ?error 66 ; 
?error_msg = "Object is remote." ; 
jmp .escape4 ; 
label .elif63 ; 
jmpc .elif64 ! == i32 i32 ?error 67 ; 
?error_msg = "Link has been severed." ; 
jmp .escape4 ; 
label .elif64 ; 
jmpc .elif65 ! == i32 i32 ?error 68 ; 
?error_msg = "Advertise error." ; 
jmp .escape4 ; 
label .elif65 ; 
jmpc .elif66 ! == i32 i32 ?error 69 ; 
?error_msg = "Srmount error." ; 
jmp .escape4 ; 
label .elif66 ; 
jmpc .elif67 ! == i32 i32 ?error 70 ; 
?error_msg = "Communication error on send." ; 
jmp .escape4 ; 
label .elif67 ; 
jmpc .elif68 ! == i32 i32 ?error 71 ; 
?error_msg = "Protocol error." ; 
jmp .escape4 ; 
label .elif68 ; 
jmpc .elif69 ! == i32 i32 ?error 72 ; 
?error_msg = "Multihop attempted." ; 
jmp .escape4 ; 
label .elif69 ; 
jmpc .elif70 ! == i32 i32 ?error 73 ; 
?error_msg = "RFS specific error." ; 
jmp .escape4 ; 
label .elif70 ; 
jmpc .elif71 ! == i32 i32 ?error 74 ; 
?error_msg = "Not a data message." ; 
jmp .escape4 ; 
label .elif71 ; 
jmpc .elif72 ! == i32 i32 ?error 75 ; 
?error_msg = "Value too large for defined data type." ; 
jmp .escape4 ; 
label .elif72 ; 
jmpc .elif73 ! == i32 i32 ?error 76 ; 
?error_msg = "Name not unique on network." ; 
jmp .escape4 ; 
label .elif73 ; 
jmpc .elif74 ! == i32 i32 ?error 77 ; 
?error_msg = "File descriptor in bad state." ; 
jmp .escape4 ; 
label .elif74 ; 
jmpc .elif75 ! == i32 i32 ?error 78 ; 
?error_msg = "Remote address changed." ; 
jmp .escape4 ; 
label .elif75 ; 
jmpc .elif76 ! == i32 i32 ?error 79 ; 
?error_msg = "Can not access a needed shared library." ; 
jmp .escape4 ; 
label .elif76 ; 
jmpc .elif77 ! == i32 i32 ?error 80 ; 
?error_msg = "Accessing a corrupted shared library." ; 
jmp .escape4 ; 
label .elif77 ; 
jmpc .elif78 ! == i32 i32 ?error 81 ; 
?error_msg = "lib section in a out corrupted." ; 
jmp .escape4 ; 
label .elif78 ; 
jmpc .elif79 ! == i32 i32 ?error 82 ; 
?error_msg = "Attempting to link in too many shared libraries." ; 
jmp .escape4 ; 
label .elif79 ; 
jmpc .elif80 ! == i32 i32 ?error 83 ; 
?error_msg = "Cannot exec a shared library directly." ; 
jmp .escape4 ; 
label .elif80 ; 
jmpc .elif81 ! == i32 i32 ?error 84 ; 
?error_msg = "Illegal byte sequence." ; 
jmp .escape4 ; 
label .elif81 ; 
jmpc .elif82 ! == i32 i32 ?error 85 ; 
?error_msg = "Interrupted system call should be restarted." ; 
jmp .escape4 ; 
label .elif82 ; 
jmpc .elif83 ! == i32 i32 ?error 86 ; 
?error_msg = "Streams pipe error." ; 
jmp .escape4 ; 
label .elif83 ; 
jmpc .elif84 ! == i32 i32 ?error 87 ; 
?error_msg = "Too many users." ; 
jmp .escape4 ; 
label .elif84 ; 
jmpc .elif85 ! == i32 i32 ?error 88 ; 
?error_msg = "Socket operation on non-socket." ; 
jmp .escape4 ; 
label .elif85 ; 
jmpc .elif86 ! == i32 i32 ?error 89 ; 
?error_msg = "Destination address required." ; 
jmp .escape4 ; 
label .elif86 ; 
jmpc .elif87 ! == i32 i32 ?error 90 ; 
?error_msg = "Message too long." ; 
jmp .escape4 ; 
label .elif87 ; 
jmpc .elif88 ! == i32 i32 ?error 91 ; 
?error_msg = "Protocol wrong type for socket." ; 
jmp .escape4 ; 
label .elif88 ; 
jmpc .elif89 ! == i32 i32 ?error 92 ; 
?error_msg = "Protocol not available." ; 
jmp .escape4 ; 
label .elif89 ; 
jmpc .elif90 ! == i32 i32 ?error 93 ; 
?error_msg = "Protocol not supported." ; 
jmp .escape4 ; 
label .elif90 ; 
jmpc .elif91 ! == i32 i32 ?error 94 ; 
?error_msg = "Socket type not supported." ; 
jmp .escape4 ; 
label .elif91 ; 
jmpc .elif92 ! == i32 i32 ?error 95 ; 
?error_msg = "Operation not supported on transport endpoint." ; 
jmp .escape4 ; 
label .elif92 ; 
jmpc .elif93 ! == i32 i32 ?error 96 ; 
?error_msg = "Protocol family not supported." ; 
jmp .escape4 ; 
label .elif93 ; 
jmpc .elif94 ! == i32 i32 ?error 97 ; 
?error_msg = "Address family not supported by protocol." ; 
jmp .escape4 ; 
label .elif94 ; 
jmpc .elif95 ! == i32 i32 ?error 98 ; 
?error_msg = "Address already in use." ; 
jmp .escape4 ; 
label .elif95 ; 
jmpc .elif96 ! == i32 i32 ?error 99 ; 
?error_msg = "Cannot assign requested address." ; 
jmp .escape4 ; 
label .elif96 ; 
jmpc .elif97 ! == i32 i32 ?error 100 ; 
?error_msg = "Network is down." ; 
jmp .escape4 ; 
label .elif97 ; 
jmpc .elif98 ! == i32 i32 ?error 101 ; 
?error_msg = "Network is unreachable." ; 
jmp .escape4 ; 
label .elif98 ; 
jmpc .elif99 ! == i32 i32 ?error 102 ; 
?error_msg = "Network dropped connection because of reset." ; 
jmp .escape4 ; 
label .elif99 ; 
jmpc .elif100 ! == i32 i32 ?error 103 ; 
?error_msg = "Software caused connection abort." ; 
jmp .escape4 ; 
label .elif100 ; 
jmpc .elif101 ! == i32 i32 ?error 104 ; 
?error_msg = "Connection reset by peer." ; 
jmp .escape4 ; 
label .elif101 ; 
jmpc .elif102 ! == i32 i32 ?error 105 ; 
?error_msg = "No buffer space available." ; 
jmp .escape4 ; 
label .elif102 ; 
jmpc .elif103 ! == i32 i32 ?error 106 ; 
?error_msg = "Transport endpoint is already connected." ; 
jmp .escape4 ; 
label .elif103 ; 
jmpc .elif104 ! == i32 i32 ?error 107 ; 
?error_msg = "Transport endpoint is not connected." ; 
jmp .escape4 ; 
label .elif104 ; 
jmpc .elif105 ! == i32 i32 ?error 108 ; 
?error_msg = "Cannot send after transport endpoint shutdown." ; 
jmp .escape4 ; 
label .elif105 ; 
jmpc .elif106 ! == i32 i32 ?error 109 ; 
?error_msg = "Too many references: cannot splice." ; 
jmp .escape4 ; 
label .elif106 ; 
jmpc .elif107 ! == i32 i32 ?error 110 ; 
?error_msg = "Connection timed out." ; 
jmp .escape4 ; 
label .elif107 ; 
jmpc .elif108 ! == i32 i32 ?error 111 ; 
?error_msg = "Connection refused." ; 
jmp .escape4 ; 
label .elif108 ; 
jmpc .elif109 ! == i32 i32 ?error 112 ; 
?error_msg = "Host is down." ; 
jmp .escape4 ; 
label .elif109 ; 
jmpc .elif110 ! == i32 i32 ?error 113 ; 
?error_msg = "No route to host." ; 
jmp .escape4 ; 
label .elif110 ; 
jmpc .elif111 ! == i32 i32 ?error 114 ; 
?error_msg = "Operation already in progress." ; 
jmp .escape4 ; 
label .elif111 ; 
jmpc .elif112 ! == i32 i32 ?error 115 ; 
?error_msg = "Operation now in progress." ; 
jmp .escape4 ; 
label .elif112 ; 
jmpc .elif113 ! == i32 i32 ?error 116 ; 
?error_msg = "Stale NFS file handle." ; 
jmp .escape4 ; 
label .elif113 ; 
jmpc .elif114 ! == i32 i32 ?error 117 ; 
?error_msg = "Structure needs cleaning." ; 
jmp .escape4 ; 
label .elif114 ; 
jmpc .elif115 ! == i32 i32 ?error 118 ; 
?error_msg = "Not a XENIX named type file." ; 
jmp .escape4 ; 
label .elif115 ; 
jmpc .elif116 ! == i32 i32 ?error 119 ; 
?error_msg = "No XENIX semaphores available." ; 
jmp .escape4 ; 
label .elif116 ; 
jmpc .elif117 ! == i32 i32 ?error 120 ; 
?error_msg = "Is a named type file." ; 
jmp .escape4 ; 
label .elif117 ; 
jmpc .elif118 ! == i32 i32 ?error 121 ; 
?error_msg = "Remote I/O error." ; 
jmp .escape4 ; 
label .elif118 ; 
jmpc .elif119 ! == i32 i32 ?error 122 ; 
?error_msg = "Quota exceeded." ; 
jmp .escape4 ; 
label .elif119 ; 
jmpc .elif120 ! == i32 i32 ?error 123 ; 
?error_msg = "No medium found." ; 
jmp .escape4 ; 
label .elif120 ; 
jmpc .elif121 ! == i32 i32 ?error 124 ; 
?error_msg = "Wrong medium type." ; 
jmp .escape4 ; 
label .elif121 ; 
jmpc .elif122 ! == i32 i32 ?error 125 ; 
?error_msg = "Operation Canceled." ; 
jmp .escape4 ; 
label .elif122 ; 
jmpc .elif123 ! == i32 i32 ?error 126 ; 
?error_msg = "Required key not available." ; 
jmp .escape4 ; 
label .elif123 ; 
jmpc .elif124 ! == i32 i32 ?error 127 ; 
?error_msg = "Key has expired." ; 
jmp .escape4 ; 
label .elif124 ; 
jmpc .elif125 ! == i32 i32 ?error 128 ; 
?error_msg = "Key has been revoked." ; 
jmp .escape4 ; 
label .elif125 ; 
jmpc .elif126 ! == i32 i32 ?error 129 ; 
?error_msg = "Key was rejected by service." ; 
jmp .escape4 ; 
label .elif126 ; 
jmpc .elif127 ! == i32 i32 ?error 130 ; 
?error_msg = "Owner died." ; 
jmp .escape4 ; 
label .elif127 ; 
jmpc .elif128 ! == i32 i32 ?error 131 ; 
?error_msg = "State not recoverable." ; 
label .escape4 ; 
label .elif128 ; 
?eptr = & ?error_msg ; 
call prints ( 2 ?eptr ) ; 
end __print_error ; 
proc readf ; 
in def i32 ?fd ; 
in def i64 ?buffer ; 
in def i32 ?length ; 
out def i32 ?len ; 
begin ; 
?length = call SYS_read ( ?fd ?buffer ?length ) ; 
jmpc .if4 ! < i32 i32 ?length 0 ; 
def i8 ?newline = 10 ; 
def i160 ?error = "Unable to read file." ; 
def i64 ?mp = & ?error ; 
call SYS_write ( 2 ?mp 21 ) ; 
def i56 ?msg = "Error: " ; 
?mp = & ?msg ; 
call SYS_write ( 2 ?mp 7 ) ; 
call __print_error ( ?length ) ; 
call printc ( 2 ?newline ) ; 
call SYS_exit ( 1 ) ; 
label .if4 ; 
?len = ?length ; 
end readf ; 
proc openf ; 
in def i64 ?filename ; 
out def i32 ?fd ; 
begin ; 
?fd = call SYS_openfd ( ?filename 2 1792 ) ; 
jmpc .if5 ! < i32 i32 ?fd 0 ; 
def i8 ?newline = 10 ; 
def i160 ?error = "Unable to open file." ; 
def i64 ?mp = & ?error ; 
call SYS_write ( 2 ?mp 21 ) ; 
def i56 ?msg = "Error: " ; 
?mp = & ?msg ; 
call SYS_write ( 2 ?mp 7 ) ; 
call __print_error ( ?fd ) ; 
call printc ( 2 ?newline ) ; 
call SYS_exit ( 1 ) ; 
label .if5 ; 
end openf ; 
proc socket ; 
in def i32 ?domain ; 
in def i32 ?type ; 
in def i32 ?protocall ; 
out def i32 ?sock ; 
begin ; 
?sock = syscall ( 41 ?domain ?type ?protocall ) ; 
jmpc .if6 ! < i32 i32 ?sock 0 ; 
def i8 ?newline = 10 ; 
def i176 ?error = "Failed to open socket." ; 
def i64 ?__error = & ?error ; 
call SYS_write ( 2 ?__error 23 ) ; 
call SYS_exit ( 1 ) ; 
label .if6 ; 
end socket ; 
proc setsockopt ; 
in def i32 ?sock ; 
in def i32 ?level ; 
in def i32 ?optname ; 
in def i64 ?optval ; 
in def i32 ?optlen ; 
begin ; 
def i32 ?err = syscall ( 54 ?sock ?level ?optname ?optval ?optlen ) ; 
jmpc .if7 ! < i32 i32 ?err 0 ; 
def i8 ?newline = 10 ; 
def i224 ?error = "Failed to set socket option." ; 
def i64 ?__error = & ?error ; 
call SYS_write ( 2 ?__error 29 ) ; 
call SYS_exit ( 1 ) ; 
label .if7 ; 
end setsockopt ; 
proc bind ; 
in def i32 ?sock ; 
in def i64 ?sockadrr ; 
in def i32 ?addrlen ; 
begin ; 
def i32 ?err = syscall ( 49 ?sock ?sockadrr ?addrlen ) ; 
jmpc .if8 ! < i32 i32 ?err 0 ; 
def i8 ?newline = 10 ; 
def i176 ?error = "Failed to bind socket." ; 
def i64 ?__error = & ?error ; 
call SYS_write ( 2 ?__error 23 ) ; 
call __print_error ( ?err ) ; 
call printc ( 2 10 ) ; 
call SYS_closefd ( ?sock ) ; 
call SYS_exit ( 1 ) ; 
label .if8 ; 
end bind ; 
proc listen ; 
in def i32 ?sock ; 
in def i32 ?backlog ; 
begin ; 
def i32 ?err = syscall ( 50 ?sock ?backlog ) ; 
jmpc .if9 ! < i32 i32 ?err 0 ; 
def i8 ?newline = 10 ; 
def i216 ?error = "Failed to listen to socket." ; 
def i64 ?__error = & ?error ; 
call SYS_write ( 2 ?__error 28 ) ; 
call SYS_exit ( 1 ) ; 
label .if9 ; 
end listen ; 
proc accept ; 
in def i32 ?sock ; 
in def i64 ?sockadrr ; 
in def i32 ?addrlen ; 
out def i32 ?fd ; 
begin ; 
?fd = syscall ( 43 ?sock ?sockadrr ?addrlen ) ; 
jmpc .if10 ! < i32 i32 ?fd 0 ; 
def i8 ?null = 0 ; 
def i8 ?nl = 10 ; 
def i136 ?error = "Failed to accept." ; 
def i64 ?__error = & ?error ; 
call prints ( 2 ?__error ) ; 
call __print_error ( ?fd ) ; 
call printc ( 2 10 ) ; 
call SYS_exit ( 1 ) ; 
label .if10 ; 
end accept ; 
proc recv ; 
in def i32 ?sockfd ; 
in def i64 ?buffer ; 
in def i32 ?size ; 
out def i32 ?read_amount ; 
begin ; 
def i64 ?NULL = 0 ; 
?read_amount = syscall ( 45 ?sockfd ?buffer ?size ?NULL 0 ) ; 
end recv ; 
proc recvERRCHECK ; 
in def i32 ?sockfd ; 
in def i64 ?buffer ; 
in def i32 ?size ; 
out def i32 ?read_amount ; 
begin ; 
def i64 ?NULL = 0 ; 
?read_amount = syscall ( 45 ?sockfd ?buffer ?size ?NULL 0 ) ; 
jmpc .if11 ! < i32 i32 ?read_amount 0 ; 
def i8 ?null = 0 ; 
def i8 ?nl = 10 ; 
def i144 ?error = "Failed to recieve." ; 
def i64 ?__error = & ?error ; 
call prints ( 2 ?__error ) ; 
call __print_error ( ?read_amount ) ; 
call printc ( 2 10 ) ; 
call SYS_exit ( 1 ) ; 
label .if11 ; 
end recvERRCHECK ; 
proc bitswap16 ; 
in def i16 ?x ; 
out def i16 ?y ; 
begin ; 
call __asm ( ; 
"  movzx eax, word [rbp-2]" ; 
"  shr ax, 8" ; 
"  mov edx, eax" ; 
"  movzx eax, word [rbp-2]" ; 
"  sal eax, 8" ; 
"  or eax, edx" ; 
"  mov word [rbp-6], ax" ; 
) ; 
end bitswap16 ; 
proc mmap ; 
in def i64 ?addr ; 
in def i32 ?length ; 
in def i32 ?prot ; 
in def i32 ?flags ; 
in def i32 ?fd ; 
in def i32 ?offset ; 
out def i64 ?ret_addr ; 
begin ; 
?ret_addr = syscall ( 9 ?addr ?length ?prot ?flags ?fd ?offset ) ; 
jmpc .if12 ! < i64 i32 ?ret_addr 0 ; 
def i8 ?null = 0 ; 
def i160 ?error = "Couldn't map memory." ; 
def i64 ?__error = & ?error ; 
call prints ( 2 ?__error ) ; 
call printc ( 2 10 ) ; 
call __print_error ( ?ret_addr ) ; 
call printc ( 2 10 ) ; 
call SYS_exit ( 1 ) ; 
label .if12 ; 
end mmap ; 
proc strb_contains ; 
in def i64 ?textSB ; 
in def i64 ?itemSB ; 
out def i8 ?TR ; 
begin ; 
def i32 ?len1 = @ offset 8 i32 ?textSB ; 
def i32 ?len2 = @ offset 8 i32 ?itemSB ; 
def i64 ?itemptr = @ offset 0 i64 ?itemSB ; 
def i32 ?i = - i32 i32 ?len1 ?len2 ; 
def i64 ?textCounter = @ offset 0 i64 ?textSB ; 
jmp .whilecmp4 ; 
label .while4 ; 
?TR = call strcmp_speclens ( ?textCounter ?len2 ?itemptr ?len2 ) ; 
jmpc .if13 ! ?TR ; 
?i = 1 ; 
label .if13 ; 
++ ?textCounter ; 
-- ?i ; 
label .whilecmp4 ; 
jmpc .while4 ?i ; 
end strb_contains ; 
proc str_contains ; 
in def i64 ?text ; 
in def i32 ?textLength ; 
in def i64 ?item ; 
in def i32 ?itemLength ; 
out def i8 ?TR ; 
begin ; 
def i96 ?xS ; 
subset i64 0 ?xS.data ?xS ; 
subset i32 8 ?xS.length ?xS ; 
?xS.data = ?text ; 
?xS.length = ?textLength ; 
def i96 ?yS ; 
subset i64 0 ?yS.data ?yS ; 
subset i32 8 ?yS.length ?yS ; 
?yS.data = ?item ; 
?yS.length = ?itemLength ; 
def i64 ?__xS = & ?xS ; 
def i64 ?__yS = & ?yS ; 
?TR = call strb_contains ( ?__xS ?__yS ) ; 
end str_contains ; 
proc getfile ; 
in def i64 ?filename ; 
out def i64 ?__data ; 
begin ; 
def i32 ?fd = call openf ( ?filename ) ; 
def i32 ?filesize = call sizeof_file ( ?fd ) ; 
def i32 ?prot = | i32 i32 1 2 ; 
def i32 ?flags = | i32 i32 2 32 ; 
def i64 ?fileaddr = call mmap ( 0 ?filesize ?prot ?flags 0 0 ) ; 
def i32 ?length = call readf ( ?fd ?fileaddr ?filesize ) ; 
call SYS_closefd ( ?fd ) ; 
def i96 ?data ; 
subset i64 0 ?data.data ?data ; 
subset i32 8 ?data.filesize ?data ; 
?data.data = ?fileaddr ; 
?data.filesize = ?filesize ; 
?__data = & ?data ; 
end getfile ; 
proc hookMessageStream ; 
in def i64 ?__msgstream ; 
begin ; 
def i32 ?one = 1 ; 
def i64 ?__one = & ?one ; 
def i32 ?sock = call socket ( 2 1 0 ) ; 
call setsockopt ( ?sock 1 2 ?__one 4 ) ; 
def i16 ?port = 8888 ; 
def i160 ?svr_addr ; 
subset i16 0 ?svr_addr.sin_family ?svr_addr ; 
subset i16 2 ?svr_addr.port ?svr_addr ; 
subset i64 4 ?svr_addr.sin_addr ?svr_addr ; 
subset i64 12 ?svr_addr.sin_zero ?svr_addr ; 
?svr_addr.sin_family = 2 ; 
?svr_addr.sin_addr = 0 ; 
?svr_addr.port = call bitswap16 ( ?port ) ; 
def i64 ?__svr_addr = & ?svr_addr ; 
call bind ( ?sock ?__svr_addr 16 ) ; 
call listen ( ?sock 5 ) ; 
def i32 ?client_fd = call accept ( ?sock 0 0 ) ; 
static def i168 ?msg2 = "got read connection\n" ; 
call prints ( 1 ?msg2 ) ; 
static def i8000 ?read_buffer ; 
& ?read_buffer ; 
def i32 ?read_amount = call recv ( ?client_fd 1000 ) ; 
jmpc .if14 ! > i32 i32 ?read_amount 0 ; 
call printi ( 1 ?read_amount ) ; 
call SYS_write ( 1 ?read_amount ) ; 
call printc ( 1 10 ) ; 
label .if14 ; 
@ offset 0 i32 ?__msgstream = ?sock ; 
@ offset 4 i32 ?__msgstream = ?client_fd ; 
end hookMessageStream ; 
proc readHandShake ; 
in def i32 ?client_fd ; 
out def i8 ?rq ; 
begin ; 
static def i8000 ?read_buffer ; 
def i32 ?read_amount = call recvERRCHECK ( ?client_fd ?read_buffer 1000 ) ; 
static def i72 ?HTMLRQ = "text/html" ; 
def i32 ?HTMLRQLength = call strlen ( ?HTMLRQ ) ; 
def i8 ?isHTMLRQ = call str_contains ( ?read_buffer ?read_amount ?HTMLRQ ?HTMLRQLength ) ; 
jmpc .if15 ! ?isHTMLRQ ; 
?rq = 1 ; 
jmp .escape23 ; 
label .if15 ; 
?rq = 0 ; 
label .escape23 ; 
end readHandShake ; 
proc main ; 
begin ; 
static def i112 ?filename = "./webpage.html" ; 
def i64 ?__file = call getfile ( ?filename ) ; 
def i96 ?file ; 
subset i64 0 ?file.data ?file ; 
subset i32 8 ?file.filesize ?file ; 
?file = @ ?__file ; 
def i32 ?one = 1 ; 
def i64 ?__one = & ?one ; 
def i32 ?sock = call socket ( 2 1 0 ) ; 
call setsockopt ( ?sock 1 2 ?__one 4 ) ; 
def i16 ?port = 8080 ; 
def i160 ?svr_addr ; 
subset i16 0 ?svr_addr.sin_family ?svr_addr ; 
subset i16 2 ?svr_addr.port ?svr_addr ; 
subset i64 4 ?svr_addr.sin_addr ?svr_addr ; 
subset i64 12 ?svr_addr.sin_zero ?svr_addr ; 
?svr_addr.sin_family = 2 ; 
?svr_addr.sin_addr = 0 ; 
?svr_addr.port = call bitswap16 ( ?port ) ; 
def i64 ?__svr_addr = & ?svr_addr ; 
call bind ( ?sock ?__svr_addr 16 ) ; 
def i8 ?x = true ; 
jmp .whilecmp5 ; 
label .while5 ; 
call listen ( ?sock 5 ) ; 
def i32 ?client_fd = call accept ( ?sock 0 0 ) ; 
static def i112 ?msg = "got connection" ; 
call prints ( 1 ?msg ) ; 
call printc ( 1 10 ) ; 
def i8 ?rq = call readHandShake ( ?client_fd ) ; 
jmpc .if16 ! == i8 i32 ?rq 1 ; 
call SYS_write ( ?client_fd ?file.data ?file.filesize ) ; 
label .if16 ; 
call SYS_closefd ( ?client_fd ) ; 
label .whilecmp5 ; 
jmpc .while5 ?x ; 
call SYS_closefd ( ?sock ) ; 
def i64 ?msgstream ; 
subset i32 0 ?msgstream.sockfd ?msgstream ; 
subset i32 4 ?msgstream.clientfd ?msgstream ; 
def i64 ?__msgstream = & ?msgstream ; 
call hookMessageStream ( ?__msgstream ) ; 
?sock = ?msgstream.sockfd ; 
?client_fd = ?msgstream.clientfd ; 
end main ; 
