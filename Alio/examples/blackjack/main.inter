proc SYS_write ; 
in def i32 ?fd ; 
in def i64 ?buffer ; 
in def i32 ?size ; 
begin ; 
syscall ( 1 ?fd ?buffer ?size ) ; 
end SYS_write ; 
proc SYS_read ; 
in def i32 ?fd ; 
in def i64 ?buffer ; 
in def i32 ?size ; 
out def i32 ?read_amount ; 
begin ; 
?read_amount = syscall ( 0 ?fd ?buffer ?size ) ; 
end SYS_read ; 
proc SYS_exit ; 
in def i32 ?error_code ; 
begin ; 
syscall ( 60 ?error_code ) ; 
end SYS_exit ; 
proc printu ; 
in def i32 ?fd ; 
in def i32 ?x ; 
begin ; 
call __asm ( ; 
"  mov    eax, edi" ; 
"  mov    ecx, 10" ; 
"  push   rcx" ; 
"  mov    rsi, rsp" ; 
"  sub    rsp, 16" ; 
".toascii_digit:" ; 
"  xor    edx, edx" ; 
"  div    ecx" ; 
"  add    edx, 48" ; 
"  dec    rsi" ; 
"  mov    [rsi], dl" ; 
"  test   eax,eax" ; 
"  jnz  .toascii_digit" ; 
"  mov    eax, 1" ; 
"  lea    edi, [rsp+16]" ; 
"  sub    edi, esi" ; 
"  mov    rax, rsi" ; 
"  mov    esi, edi" ; 
"  mov    rdi, rax" ; 
"  mov    eax, dword [rbp-4]" ; 
) ; 
call SYS_write ( ) ; 
call __asm ( "  add rsp, 24" ) ; 
end printu ; 
proc printc ; 
in def i32 ?fd ; 
in def i8 ?x ; 
begin ; 
def i64 ?y = & ?x ; 
call SYS_write ( ?fd ?y 1 ) ; 
end printc ; 
proc strlen ; 
in def i64 ?str ; 
out def i32 ?len ; 
begin ; 
def i64 ?beginning = ?str ; 
def i8 ?c = @ ?str ; 
jmp .whilecmp1 ; 
label .while1 ; 
++ ?str ; 
?c = @ ?str ; 
label .whilecmp1 ; 
jmpc .while1 ?c ; 
?len = - i64 i64 ?str ?beginning ; 
end strlen ; 
proc strcmp ; 
in def i64 ?str1 ; 
in def i64 ?str2 ; 
out def i8 ?equals? ; 
begin ; 
def i32 ?len1 = call strlen ( ?str1 ) ; 
def i32 ?len2 = call strlen ( ?str2 ) ; 
?equals? = == i32 i32 ?len1 ?len2 ; 
jmpc .if1 ! ?equals? ; 
def i8 ?continue = true ; 
def i8 ?i = 0 ; 
jmp .whilecmp2 ; 
label .while2 ; 
def i8 ?c1 = @ ?str1 ; 
def i8 ?c2 = @ ?str2 ; 
?equals? = == i8 i8 ?c1 ?c2 ; 
def i8 ?nend = < i8 i32 ?i ?len1 ; 
?continue = && i8 i8 ?equals? ?nend ; 
++ ?i ; 
++ ?str1 ; 
++ ?str2 ; 
label .whilecmp2 ; 
jmpc .while2 ?continue ; 
label .if1 ; 
end strcmp ; 
proc prints ; 
in def i32 ?fd ; 
in def i64 ?str ; 
begin ; 
def i32 ?len = call strlen ( ?str ) ; 
call SYS_write ( ?fd ?str ?len ) ; 
end prints ; 
proc __print_error ; 
in def i32 ?error ; 
begin ; 
?error = - i32 i32 4294967294 ?error ; 
?error = + i32 i32 ?error 2 ; 
def i2048 ?error_msg ; 
def i64 ?eptr = & ?error_msg ; 
def i64 ?null = 0 ; 
def i32 ?i = 0 ; 
jmp .whilecmp3 ; 
label .while3 ; 
@ ?eptr i64 ?null ; 
?eptr = + i64 i32 ?eptr 8 ; 
?i = + i32 i32 ?i 8 ; 
label .whilecmp3 ; 
jmpc .while3 < i32 i32 ?i 256 ; 
?eptr = & ?error_msg ; 
jmpc .if2 ! == i32 i32 ?error 1 ; 
?error_msg = "Operation not permitted." ; 
jmp .escape3 ; 
label .if2 ; 
jmpc .elif1 ! == i32 i32 ?error 2 ; 
?error_msg = "No such file or directory." ; 
jmp .escape3 ; 
label .elif1 ; 
jmpc .elif2 ! == i32 i32 ?error 3 ; 
?error_msg = "No such process." ; 
jmp .escape3 ; 
label .elif2 ; 
jmpc .elif3 ! == i32 i32 ?error 4 ; 
?error_msg = "Interrupted system call." ; 
jmp .escape3 ; 
label .elif3 ; 
jmpc .elif4 ! == i32 i32 ?error 5 ; 
?error_msg = "I/O error." ; 
jmp .escape3 ; 
label .elif4 ; 
jmpc .elif5 ! == i32 i32 ?error 6 ; 
?error_msg = "No such device or address." ; 
jmp .escape3 ; 
label .elif5 ; 
jmpc .elif6 ! == i32 i32 ?error 7 ; 
?error_msg = "Argument list too long." ; 
jmp .escape3 ; 
label .elif6 ; 
jmpc .elif7 ! == i32 i32 ?error 8 ; 
?error_msg = "Exec format error." ; 
jmp .escape3 ; 
label .elif7 ; 
jmpc .elif8 ! == i32 i32 ?error 9 ; 
?error_msg = "Bad file number." ; 
jmp .escape3 ; 
label .elif8 ; 
jmpc .elif9 ! == i32 i32 ?error 10 ; 
?error_msg = "No child processes." ; 
jmp .escape3 ; 
label .elif9 ; 
jmpc .elif10 ! == i32 i32 ?error 11 ; 
?error_msg = "Try again." ; 
jmp .escape3 ; 
label .elif10 ; 
jmpc .elif11 ! == i32 i32 ?error 12 ; 
?error_msg = "Out of memory." ; 
jmp .escape3 ; 
label .elif11 ; 
jmpc .elif12 ! == i32 i32 ?error 13 ; 
?error_msg = "Permission denied." ; 
jmp .escape3 ; 
label .elif12 ; 
jmpc .elif13 ! == i32 i32 ?error 14 ; 
?error_msg = "Bad address." ; 
jmp .escape3 ; 
label .elif13 ; 
jmpc .elif14 ! == i32 i32 ?error 15 ; 
?error_msg = "Block device required." ; 
jmp .escape3 ; 
label .elif14 ; 
jmpc .elif15 ! == i32 i32 ?error 16 ; 
?error_msg = "Device or resource busy." ; 
jmp .escape3 ; 
label .elif15 ; 
jmpc .elif16 ! == i32 i32 ?error 17 ; 
?error_msg = "File exists." ; 
jmp .escape3 ; 
label .elif16 ; 
jmpc .elif17 ! == i32 i32 ?error 18 ; 
?error_msg = "Cross-device link." ; 
jmp .escape3 ; 
label .elif17 ; 
jmpc .elif18 ! == i32 i32 ?error 19 ; 
?error_msg = "No such device." ; 
jmp .escape3 ; 
label .elif18 ; 
jmpc .elif19 ! == i32 i32 ?error 20 ; 
?error_msg = "Not a directory." ; 
jmp .escape3 ; 
label .elif19 ; 
jmpc .elif20 ! == i32 i32 ?error 21 ; 
?error_msg = "Is a directory." ; 
jmp .escape3 ; 
label .elif20 ; 
jmpc .elif21 ! == i32 i32 ?error 22 ; 
?error_msg = "Invalid argument." ; 
jmp .escape3 ; 
label .elif21 ; 
jmpc .elif22 ! == i32 i32 ?error 23 ; 
?error_msg = "File table overflow." ; 
jmp .escape3 ; 
label .elif22 ; 
jmpc .elif23 ! == i32 i32 ?error 24 ; 
?error_msg = "Too many open files." ; 
jmp .escape3 ; 
label .elif23 ; 
jmpc .elif24 ! == i32 i32 ?error 25 ; 
?error_msg = "Not a typewriter." ; 
jmp .escape3 ; 
label .elif24 ; 
jmpc .elif25 ! == i32 i32 ?error 26 ; 
?error_msg = "Text file busy." ; 
jmp .escape3 ; 
label .elif25 ; 
jmpc .elif26 ! == i32 i32 ?error 27 ; 
?error_msg = "File too large." ; 
jmp .escape3 ; 
label .elif26 ; 
jmpc .elif27 ! == i32 i32 ?error 28 ; 
?error_msg = "No space left on device." ; 
jmp .escape3 ; 
label .elif27 ; 
jmpc .elif28 ! == i32 i32 ?error 29 ; 
?error_msg = "Illegal seek." ; 
jmp .escape3 ; 
label .elif28 ; 
jmpc .elif29 ! == i32 i32 ?error 30 ; 
?error_msg = "Read-only file system." ; 
jmp .escape3 ; 
label .elif29 ; 
jmpc .elif30 ! == i32 i32 ?error 31 ; 
?error_msg = "Too many links." ; 
jmp .escape3 ; 
label .elif30 ; 
jmpc .elif31 ! == i32 i32 ?error 32 ; 
?error_msg = "Broken pipe." ; 
jmp .escape3 ; 
label .elif31 ; 
jmpc .elif32 ! == i32 i32 ?error 33 ; 
?error_msg = "Math argument out of domain of func." ; 
jmp .escape3 ; 
label .elif32 ; 
jmpc .elif33 ! == i32 i32 ?error 34 ; 
?error_msg = "Math result not representable." ; 
jmp .escape3 ; 
label .elif33 ; 
jmpc .elif34 ! == i32 i32 ?error 35 ; 
?error_msg = "Resource deadlock would occur." ; 
jmp .escape3 ; 
label .elif34 ; 
jmpc .elif35 ! == i32 i32 ?error 36 ; 
?error_msg = "File name too long." ; 
jmp .escape3 ; 
label .elif35 ; 
jmpc .elif36 ! == i32 i32 ?error 37 ; 
?error_msg = "No record locks available." ; 
jmp .escape3 ; 
label .elif36 ; 
jmpc .elif37 ! == i32 i32 ?error 38 ; 
?error_msg = "Function not implemented." ; 
jmp .escape3 ; 
label .elif37 ; 
jmpc .elif38 ! == i32 i32 ?error 39 ; 
?error_msg = "Directory not empty." ; 
jmp .escape3 ; 
label .elif38 ; 
jmpc .elif39 ! == i32 i32 ?error 40 ; 
?error_msg = "Too many symbolic links encountered." ; 
jmp .escape3 ; 
label .elif39 ; 
jmpc .elif40 ! == i32 i32 ?error 42 ; 
?error_msg = "No message of desired type." ; 
jmp .escape3 ; 
label .elif40 ; 
jmpc .elif41 ! == i32 i32 ?error 43 ; 
?error_msg = "Identifier removed." ; 
jmp .escape3 ; 
label .elif41 ; 
jmpc .elif42 ! == i32 i32 ?error 44 ; 
?error_msg = "Channel number out of range." ; 
jmp .escape3 ; 
label .elif42 ; 
jmpc .elif43 ! == i32 i32 ?error 45 ; 
?error_msg = "Level 2 not synchronized." ; 
jmp .escape3 ; 
label .elif43 ; 
jmpc .elif44 ! == i32 i32 ?error 46 ; 
?error_msg = "Level 3 halted." ; 
jmp .escape3 ; 
label .elif44 ; 
jmpc .elif45 ! == i32 i32 ?error 47 ; 
?error_msg = "Level 3 reset." ; 
jmp .escape3 ; 
label .elif45 ; 
jmpc .elif46 ! == i32 i32 ?error 48 ; 
?error_msg = "Link number out of range." ; 
jmp .escape3 ; 
label .elif46 ; 
jmpc .elif47 ! == i32 i32 ?error 49 ; 
?error_msg = "Protocol driver not attached." ; 
jmp .escape3 ; 
label .elif47 ; 
jmpc .elif48 ! == i32 i32 ?error 50 ; 
?error_msg = "No CSI structure available." ; 
jmp .escape3 ; 
label .elif48 ; 
jmpc .elif49 ! == i32 i32 ?error 51 ; 
?error_msg = "Level 2 halted." ; 
jmp .escape3 ; 
label .elif49 ; 
jmpc .elif50 ! == i32 i32 ?error 52 ; 
?error_msg = "Invalid exchange." ; 
jmp .escape3 ; 
label .elif50 ; 
jmpc .elif51 ! == i32 i32 ?error 53 ; 
?error_msg = "Invalid request descriptor." ; 
jmp .escape3 ; 
label .elif51 ; 
jmpc .elif52 ! == i32 i32 ?error 54 ; 
?error_msg = "Exchange full." ; 
jmp .escape3 ; 
label .elif52 ; 
jmpc .elif53 ! == i32 i32 ?error 55 ; 
?error_msg = "No anode." ; 
jmp .escape3 ; 
label .elif53 ; 
jmpc .elif54 ! == i32 i32 ?error 56 ; 
?error_msg = "Invalid request code." ; 
jmp .escape3 ; 
label .elif54 ; 
jmpc .elif55 ! == i32 i32 ?error 57 ; 
?error_msg = "Invalid slot." ; 
jmp .escape3 ; 
label .elif55 ; 
jmpc .elif56 ! == i32 i32 ?error 59 ; 
?error_msg = "Bad font file format." ; 
jmp .escape3 ; 
label .elif56 ; 
jmpc .elif57 ! == i32 i32 ?error 60 ; 
?error_msg = "Device not a stream." ; 
jmp .escape3 ; 
label .elif57 ; 
jmpc .elif58 ! == i32 i32 ?error 61 ; 
?error_msg = "No data available." ; 
jmp .escape3 ; 
label .elif58 ; 
jmpc .elif59 ! == i32 i32 ?error 62 ; 
?error_msg = "Timer expired." ; 
jmp .escape3 ; 
label .elif59 ; 
jmpc .elif60 ! == i32 i32 ?error 63 ; 
?error_msg = "Out of streams resources." ; 
jmp .escape3 ; 
label .elif60 ; 
jmpc .elif61 ! == i32 i32 ?error 64 ; 
?error_msg = "Machine is not on the network." ; 
jmp .escape3 ; 
label .elif61 ; 
jmpc .elif62 ! == i32 i32 ?error 65 ; 
?error_msg = "Package not installed." ; 
jmp .escape3 ; 
label .elif62 ; 
jmpc .elif63 ! == i32 i32 ?error 66 ; 
?error_msg = "Object is remote." ; 
jmp .escape3 ; 
label .elif63 ; 
jmpc .elif64 ! == i32 i32 ?error 67 ; 
?error_msg = "Link has been severed." ; 
jmp .escape3 ; 
label .elif64 ; 
jmpc .elif65 ! == i32 i32 ?error 68 ; 
?error_msg = "Advertise error." ; 
jmp .escape3 ; 
label .elif65 ; 
jmpc .elif66 ! == i32 i32 ?error 69 ; 
?error_msg = "Srmount error." ; 
jmp .escape3 ; 
label .elif66 ; 
jmpc .elif67 ! == i32 i32 ?error 70 ; 
?error_msg = "Communication error on send." ; 
jmp .escape3 ; 
label .elif67 ; 
jmpc .elif68 ! == i32 i32 ?error 71 ; 
?error_msg = "Protocol error." ; 
jmp .escape3 ; 
label .elif68 ; 
jmpc .elif69 ! == i32 i32 ?error 72 ; 
?error_msg = "Multihop attempted." ; 
jmp .escape3 ; 
label .elif69 ; 
jmpc .elif70 ! == i32 i32 ?error 73 ; 
?error_msg = "RFS specific error." ; 
jmp .escape3 ; 
label .elif70 ; 
jmpc .elif71 ! == i32 i32 ?error 74 ; 
?error_msg = "Not a data message." ; 
jmp .escape3 ; 
label .elif71 ; 
jmpc .elif72 ! == i32 i32 ?error 75 ; 
?error_msg = "Value too large for defined data type." ; 
jmp .escape3 ; 
label .elif72 ; 
jmpc .elif73 ! == i32 i32 ?error 76 ; 
?error_msg = "Name not unique on network." ; 
jmp .escape3 ; 
label .elif73 ; 
jmpc .elif74 ! == i32 i32 ?error 77 ; 
?error_msg = "File descriptor in bad state." ; 
jmp .escape3 ; 
label .elif74 ; 
jmpc .elif75 ! == i32 i32 ?error 78 ; 
?error_msg = "Remote address changed." ; 
jmp .escape3 ; 
label .elif75 ; 
jmpc .elif76 ! == i32 i32 ?error 79 ; 
?error_msg = "Can not access a needed shared library." ; 
jmp .escape3 ; 
label .elif76 ; 
jmpc .elif77 ! == i32 i32 ?error 80 ; 
?error_msg = "Accessing a corrupted shared library." ; 
jmp .escape3 ; 
label .elif77 ; 
jmpc .elif78 ! == i32 i32 ?error 81 ; 
?error_msg = "lib section in a out corrupted." ; 
jmp .escape3 ; 
label .elif78 ; 
jmpc .elif79 ! == i32 i32 ?error 82 ; 
?error_msg = "Attempting to link in too many shared libraries." ; 
jmp .escape3 ; 
label .elif79 ; 
jmpc .elif80 ! == i32 i32 ?error 83 ; 
?error_msg = "Cannot exec a shared library directly." ; 
jmp .escape3 ; 
label .elif80 ; 
jmpc .elif81 ! == i32 i32 ?error 84 ; 
?error_msg = "Illegal byte sequence." ; 
jmp .escape3 ; 
label .elif81 ; 
jmpc .elif82 ! == i32 i32 ?error 85 ; 
?error_msg = "Interrupted system call should be restarted." ; 
jmp .escape3 ; 
label .elif82 ; 
jmpc .elif83 ! == i32 i32 ?error 86 ; 
?error_msg = "Streams pipe error." ; 
jmp .escape3 ; 
label .elif83 ; 
jmpc .elif84 ! == i32 i32 ?error 87 ; 
?error_msg = "Too many users." ; 
jmp .escape3 ; 
label .elif84 ; 
jmpc .elif85 ! == i32 i32 ?error 88 ; 
?error_msg = "Socket operation on non-socket." ; 
jmp .escape3 ; 
label .elif85 ; 
jmpc .elif86 ! == i32 i32 ?error 89 ; 
?error_msg = "Destination address required." ; 
jmp .escape3 ; 
label .elif86 ; 
jmpc .elif87 ! == i32 i32 ?error 90 ; 
?error_msg = "Message too long." ; 
jmp .escape3 ; 
label .elif87 ; 
jmpc .elif88 ! == i32 i32 ?error 91 ; 
?error_msg = "Protocol wrong type for socket." ; 
jmp .escape3 ; 
label .elif88 ; 
jmpc .elif89 ! == i32 i32 ?error 92 ; 
?error_msg = "Protocol not available." ; 
jmp .escape3 ; 
label .elif89 ; 
jmpc .elif90 ! == i32 i32 ?error 93 ; 
?error_msg = "Protocol not supported." ; 
jmp .escape3 ; 
label .elif90 ; 
jmpc .elif91 ! == i32 i32 ?error 94 ; 
?error_msg = "Socket type not supported." ; 
jmp .escape3 ; 
label .elif91 ; 
jmpc .elif92 ! == i32 i32 ?error 95 ; 
?error_msg = "Operation not supported on transport endpoint." ; 
jmp .escape3 ; 
label .elif92 ; 
jmpc .elif93 ! == i32 i32 ?error 96 ; 
?error_msg = "Protocol family not supported." ; 
jmp .escape3 ; 
label .elif93 ; 
jmpc .elif94 ! == i32 i32 ?error 97 ; 
?error_msg = "Address family not supported by protocol." ; 
jmp .escape3 ; 
label .elif94 ; 
jmpc .elif95 ! == i32 i32 ?error 98 ; 
?error_msg = "Address already in use." ; 
jmp .escape3 ; 
label .elif95 ; 
jmpc .elif96 ! == i32 i32 ?error 99 ; 
?error_msg = "Cannot assign requested address." ; 
jmp .escape3 ; 
label .elif96 ; 
jmpc .elif97 ! == i32 i32 ?error 100 ; 
?error_msg = "Network is down." ; 
jmp .escape3 ; 
label .elif97 ; 
jmpc .elif98 ! == i32 i32 ?error 101 ; 
?error_msg = "Network is unreachable." ; 
jmp .escape3 ; 
label .elif98 ; 
jmpc .elif99 ! == i32 i32 ?error 102 ; 
?error_msg = "Network dropped connection because of reset." ; 
jmp .escape3 ; 
label .elif99 ; 
jmpc .elif100 ! == i32 i32 ?error 103 ; 
?error_msg = "Software caused connection abort." ; 
jmp .escape3 ; 
label .elif100 ; 
jmpc .elif101 ! == i32 i32 ?error 104 ; 
?error_msg = "Connection reset by peer." ; 
jmp .escape3 ; 
label .elif101 ; 
jmpc .elif102 ! == i32 i32 ?error 105 ; 
?error_msg = "No buffer space available." ; 
jmp .escape3 ; 
label .elif102 ; 
jmpc .elif103 ! == i32 i32 ?error 106 ; 
?error_msg = "Transport endpoint is already connected." ; 
jmp .escape3 ; 
label .elif103 ; 
jmpc .elif104 ! == i32 i32 ?error 107 ; 
?error_msg = "Transport endpoint is not connected." ; 
jmp .escape3 ; 
label .elif104 ; 
jmpc .elif105 ! == i32 i32 ?error 108 ; 
?error_msg = "Cannot send after transport endpoint shutdown." ; 
jmp .escape3 ; 
label .elif105 ; 
jmpc .elif106 ! == i32 i32 ?error 109 ; 
?error_msg = "Too many references: cannot splice." ; 
jmp .escape3 ; 
label .elif106 ; 
jmpc .elif107 ! == i32 i32 ?error 110 ; 
?error_msg = "Connection timed out." ; 
jmp .escape3 ; 
label .elif107 ; 
jmpc .elif108 ! == i32 i32 ?error 111 ; 
?error_msg = "Connection refused." ; 
jmp .escape3 ; 
label .elif108 ; 
jmpc .elif109 ! == i32 i32 ?error 112 ; 
?error_msg = "Host is down." ; 
jmp .escape3 ; 
label .elif109 ; 
jmpc .elif110 ! == i32 i32 ?error 113 ; 
?error_msg = "No route to host." ; 
jmp .escape3 ; 
label .elif110 ; 
jmpc .elif111 ! == i32 i32 ?error 114 ; 
?error_msg = "Operation already in progress." ; 
jmp .escape3 ; 
label .elif111 ; 
jmpc .elif112 ! == i32 i32 ?error 115 ; 
?error_msg = "Operation now in progress." ; 
jmp .escape3 ; 
label .elif112 ; 
jmpc .elif113 ! == i32 i32 ?error 116 ; 
?error_msg = "Stale NFS file handle." ; 
jmp .escape3 ; 
label .elif113 ; 
jmpc .elif114 ! == i32 i32 ?error 117 ; 
?error_msg = "Structure needs cleaning." ; 
jmp .escape3 ; 
label .elif114 ; 
jmpc .elif115 ! == i32 i32 ?error 118 ; 
?error_msg = "Not a XENIX named type file." ; 
jmp .escape3 ; 
label .elif115 ; 
jmpc .elif116 ! == i32 i32 ?error 119 ; 
?error_msg = "No XENIX semaphores available." ; 
jmp .escape3 ; 
label .elif116 ; 
jmpc .elif117 ! == i32 i32 ?error 120 ; 
?error_msg = "Is a named type file." ; 
jmp .escape3 ; 
label .elif117 ; 
jmpc .elif118 ! == i32 i32 ?error 121 ; 
?error_msg = "Remote I/O error." ; 
jmp .escape3 ; 
label .elif118 ; 
jmpc .elif119 ! == i32 i32 ?error 122 ; 
?error_msg = "Quota exceeded." ; 
jmp .escape3 ; 
label .elif119 ; 
jmpc .elif120 ! == i32 i32 ?error 123 ; 
?error_msg = "No medium found." ; 
jmp .escape3 ; 
label .elif120 ; 
jmpc .elif121 ! == i32 i32 ?error 124 ; 
?error_msg = "Wrong medium type." ; 
jmp .escape3 ; 
label .elif121 ; 
jmpc .elif122 ! == i32 i32 ?error 125 ; 
?error_msg = "Operation Canceled." ; 
jmp .escape3 ; 
label .elif122 ; 
jmpc .elif123 ! == i32 i32 ?error 126 ; 
?error_msg = "Required key not available." ; 
jmp .escape3 ; 
label .elif123 ; 
jmpc .elif124 ! == i32 i32 ?error 127 ; 
?error_msg = "Key has expired." ; 
jmp .escape3 ; 
label .elif124 ; 
jmpc .elif125 ! == i32 i32 ?error 128 ; 
?error_msg = "Key has been revoked." ; 
jmp .escape3 ; 
label .elif125 ; 
jmpc .elif126 ! == i32 i32 ?error 129 ; 
?error_msg = "Key was rejected by service." ; 
jmp .escape3 ; 
label .elif126 ; 
jmpc .elif127 ! == i32 i32 ?error 130 ; 
?error_msg = "Owner died." ; 
jmp .escape3 ; 
label .elif127 ; 
jmpc .elif128 ! == i32 i32 ?error 131 ; 
?error_msg = "State not recoverable." ; 
label .escape3 ; 
label .elif128 ; 
?eptr = & ?error_msg ; 
call prints ( 2 ?eptr ) ; 
end __print_error ; 
proc readf ; 
in def i32 ?fd ; 
in def i64 ?buffer ; 
in def i32 ?length ; 
out def i32 ?len ; 
begin ; 
?length = call SYS_read ( ?fd ?buffer ?length ) ; 
jmpc .if3 ! < i32 i32 ?length 0 ; 
def i8 ?newline = 10 ; 
def i160 ?error = "Unable to read file." ; 
def i64 ?mp = & ?error ; 
call SYS_write ( 2 ?mp 21 ) ; 
def i56 ?msg = "Error: " ; 
?mp = & ?msg ; 
call SYS_write ( 2 ?mp 7 ) ; 
call __print_error ( ?length ) ; 
call printc ( 2 ?newline ) ; 
call SYS_exit ( 1 ) ; 
label .if3 ; 
?len = ?length ; 
end readf ; 
persist proc __rand_scope ; 
begin ; 
static def i64 ?step ; 
def i64 ?l = 140733482129552 ; 
?step = ?l ; 
end __rand_scope ; 
proc hash_seed ; 
out def i64 ?newseed ; 
begin ; 
global :: __rand_scope ?step ; 
def i64 ?__step = & ?step ; 
?step = + i64 i32 ?step 1 ; 
?step = * i64 i32 ?step 7 ; 
?newseed = @ ?__step ; 
?newseed = + i64 i64 ?newseed ?__step ; 
end hash_seed ; 
proc rand_uint_range ; 
in def i32 ?minI ; 
in def i32 ?maxI ; 
out def i32 ?numberI ; 
begin ; 
?numberI = call hash_seed ( ) ; 
def i32 ?greaterThanNeg = < i32 i32 ?numberI 0 ; 
jmpc .if4 ! ?greaterThanNeg ; 
?numberI = - i32 i32 ?numberI 2147483648 ; 
label .if4 ; 
def i32 ?rangeI = - i32 i32 ?minI ?maxI ; 
def i32 ?numberGreaterThanRangeI = > i32 i32 ?numberI ?rangeI ; 
?numberI = % i32 i32 ?numberI ?rangeI ; 
?numberI = + i32 i32 ?numberI ?minI ; 
end rand_uint_range ; 
proc coinflip ; 
out def i8 ?tr ; 
begin ; 
def i32 ?number = call hash_seed ( ) ; 
jmpc .if5 ! < i32 i32 ?number 0 ; 
?number = + i32 i32 ?number 127 ; 
label .if5 ; 
?tr = % i32 i32 ?number 2 ; 
end coinflip ; 
proc displayHands ; 
in def i64 ?__pkt ; 
begin ; 
static def i136 ?prompt = "Your cards were: " ; 
call prints ( 1 ?prompt ) ; 
def i32 ?displayInt = 0 ; 
def i8 ?byte = @ offset 0 i8 ?__pkt ; 
?displayInt = ?byte ; 
jmpc .if6 ! != i32 i32 ?displayInt 1 ; 
call printu ( 1 ?displayInt ) ; 
jmp .escape14 ; 
label .if6 ; 
call printc ( 1 "A" ) ; 
label .escape14 ; 
call printc ( 1 " " ) ; 
?byte = @ offset 1 i8 ?__pkt ; 
?displayInt = ?byte ; 
jmpc .if7 ! != i32 i32 ?displayInt 1 ; 
call printu ( 1 ?displayInt ) ; 
jmp .escape15 ; 
label .if7 ; 
call printc ( 1 "A" ) ; 
label .escape15 ; 
call printc ( 1 " " ) ; 
def i32 ?i = 0 ; 
def i8 ?length = @ offset 10 i8 ?__pkt ; 
def i64 ?__cards = @ offset 2 i64 ?__pkt ; 
jmp .whilecmp4 ; 
label .while4 ; 
?byte = @ ?__cards ; 
?displayInt = ?byte ; 
jmpc .if8 ! != i32 i32 ?displayInt 1 ; 
call printu ( 1 ?displayInt ) ; 
jmp .escape16 ; 
label .if8 ; 
call printc ( 1 "A" ) ; 
label .escape16 ; 
call printc ( 1 " " ) ; 
++ ?__cards ; 
++ ?i ; 
label .whilecmp4 ; 
jmpc .while4 < i32 i8 ?i ?length ; 
call printc ( 1 10 ) ; 
static def i200 ?prompt2 = "The dealer's cards were: " ; 
call prints ( 1 ?prompt2 ) ; 
def i32 ?displayInt = 0 ; 
def i8 ?byte = @ offset 12 i8 ?__pkt ; 
?displayInt = ?byte ; 
jmpc .if9 ! != i32 i32 ?displayInt 1 ; 
call printu ( 1 ?displayInt ) ; 
jmp .escape17 ; 
label .if9 ; 
call printc ( 1 "A" ) ; 
label .escape17 ; 
call printc ( 1 " " ) ; 
?byte = @ offset 13 i8 ?__pkt ; 
?displayInt = ?byte ; 
jmpc .if10 ! != i32 i32 ?displayInt 1 ; 
call printu ( 1 ?displayInt ) ; 
jmp .escape18 ; 
label .if10 ; 
call printc ( 1 "A" ) ; 
label .escape18 ; 
call printc ( 1 " " ) ; 
def i32 ?i = 0 ; 
def i8 ?length = @ offset 22 i8 ?__pkt ; 
def i64 ?__cards = @ offset 14 i64 ?__pkt ; 
jmp .whilecmp5 ; 
label .while5 ; 
?byte = @ ?__cards ; 
?displayInt = ?byte ; 
jmpc .if11 ! != i32 i32 ?displayInt 1 ; 
call printu ( 1 ?displayInt ) ; 
jmp .escape19 ; 
label .if11 ; 
call printc ( 1 "A" ) ; 
label .escape19 ; 
call printc ( 1 " " ) ; 
++ ?__cards ; 
++ ?i ; 
label .whilecmp5 ; 
jmpc .while5 < i32 i8 ?i ?length ; 
call printc ( 1 10 ) ; 
end displayHands ; 
proc countCardTotal ; 
in def i64 ?__hand ; 
begin ; 
def i8 ?isAce = false ; 
def i8 ?sum = 0 ; 
def i8 ?card1 = @ offset 0 i8 ?__hand ; 
def i8 ?card2 = @ offset 1 i8 ?__hand ; 
jmpc .if12 ! == i8 i32 ?card1 1 ; 
?isAce = true ; 
label .if12 ; 
jmpc .if13 ! == i8 i32 ?card2 1 ; 
?isAce = true ; 
label .if13 ; 
?sum = + i8 i8 ?card1 ?card2 ; 
def i32 ?i = 0 ; 
def i8 ?byte ; 
def i64 ?__cards = @ offset 2 i64 ?__hand ; 
def i8 ?length = @ offset 10 i8 ?__hand ; 
jmp .whilecmp6 ; 
label .while6 ; 
?byte = @ ?__cards ; 
?sum = + i8 i8 ?byte ?sum ; 
jmpc .if14 ! == i8 i32 ?byte 1 ; 
?isAce = true ; 
label .if14 ; 
++ ?__cards ; 
++ ?i ; 
label .whilecmp6 ; 
jmpc .while6 < i32 i8 ?i ?length ; 
jmpc .if15 ! ?isAce ; 
def i8 ?predictedsum = + i8 i32 ?sum 10 ; 
jmpc .if16 ! <= i8 i32 ?predictedsum 21 ; 
?sum = ?predictedsum ; 
label .if16 ; 
label .if15 ; 
@ offset 11 i8 ?__hand = ?sum ; 
end countCardTotal ; 
proc addCardToPlayerHand ; 
in def i64 ?__pkt ; 
in def i8 ?card ; 
begin ; 
def i8 ?index = 0 ; 
?index = @ offset 10 i8 ?__pkt ; 
def i64 ?arr = @ offset 2 i64 ?__pkt ; 
?arr = + i64 i8 ?arr ?index ; 
@ ?arr i8 ?card ; 
def i8 ?byte = + i8 i32 ?index 1 ; 
@ offset 10 i8 ?__pkt = ?byte ; 
call countCardTotal ( ?__pkt ) ; 
end addCardToPlayerHand ; 
proc addCardToDealerHand ; 
in def i64 ?__pkt ; 
in def i8 ?card ; 
begin ; 
def i8 ?index = 0 ; 
?index = @ offset 22 i8 ?__pkt ; 
def i64 ?arr = @ offset 14 i64 ?__pkt ; 
?arr = + i64 i8 ?arr ?index ; 
@ ?arr i8 ?card ; 
def i8 ?byte = + i8 i32 ?index 1 ; 
@ offset 22 i8 ?__pkt = ?byte ; 
?arr = ?__pkt ; 
?arr = + i64 i32 ?arr 12 ; 
call countCardTotal ( ?arr ) ; 
end addCardToDealerHand ; 
proc Deck@pullcard ; 
in def i64 ?self ; 
out def i8 ?card ; 
begin ; 
def i64 ?__self = ?self ; 
def i64 ?__cards = @ offset 0 i64 ?__self ; 
?card = @ ?__cards ; 
jmp .whilecmp7 ; 
label .while7 ; 
++ ?__cards ; 
?card = @ ?__cards ; 
label .whilecmp7 ; 
jmpc .while7 ! ?card ; 
def i8 ?byte = 0 ; 
@ ?__cards i8 ?byte ; 
def i64 ?buffer ; 
end Deck@pullcard ; 
proc shuffle ; 
in def i64 ?__deck ; 
begin ; 
def i64 ?arr = @ offset 0 i64 ?__deck ; 
def i208 ?firstHalf ; 
def i208 ?secondHalf ; 
def i64 ?__firstHalf = & ?firstHalf ; 
def i64 ?__secondHalf = & ?secondHalf ; 
def i64 ?src1 = ?arr ; 
def i64 ?src2 = + i64 i32 ?arr 26 ; 
def i8 ?c = @ ?src1 ; 
def i8 ?d = @ ?src2 ; 
def i32 ?i = 0 ; 
jmp .whilecmp8 ; 
label .while8 ; 
@ ?__firstHalf i8 ?c ; 
++ ?src1 ; 
++ ?__firstHalf ; 
?c = @ ?src1 ; 
@ ?__secondHalf i8 ?d ; 
++ ?src2 ; 
++ ?__secondHalf ; 
?d = @ ?src2 ; 
++ ?i ; 
label .whilecmp8 ; 
jmpc .while8 < i32 i32 ?i 26 ; 
?__firstHalf = & ?firstHalf ; 
?__secondHalf = & ?secondHalf ; 
def i8 ?byte = 0 ; 
def i8 ?tr = 0 ; 
?i = 0 ; 
jmp .whilecmp9 ; 
label .while9 ; 
?tr = call coinflip ( ) ; 
jmpc .if17 ! ?tr ; 
?byte = @ ?__firstHalf ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
++ ?__firstHalf ; 
?byte = @ ?__secondHalf ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
++ ?__secondHalf ; 
++ ?i ; 
jmp .escape25 ; 
label .if17 ; 
?byte = @ ?__secondHalf ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
++ ?__secondHalf ; 
++ ?i ; 
?byte = @ ?__firstHalf ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
++ ?__firstHalf ; 
label .escape25 ; 
label .whilecmp9 ; 
jmpc .while9 < i32 i32 ?i 26 ; 
end shuffle ; 
proc initDeck ; 
begin ; 
static def i64 ?deck ; 
subset i64 0 ?deck.cards ?deck ; 
static def i416 ?cards ; 
?deck.cards = & ?cards ; 
def i64 ?arr = ?deck.cards ; 
def i8 ?byte = 1 ; 
def i32 ?i = 0 ; 
jmp .whilecmp10 ; 
label .while10 ; 
?byte = 1 ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
?byte = 2 ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
?byte = 3 ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
?byte = 4 ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
?byte = 5 ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
?byte = 6 ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
?byte = 7 ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
?byte = 8 ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
?byte = 9 ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
?byte = 10 ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
?byte = 10 ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
?byte = 10 ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
?byte = 10 ; 
@ ?arr i8 ?byte ; 
++ ?arr ; 
++ ?i ; 
label .whilecmp10 ; 
jmpc .while10 < i32 i32 ?i 4 ; 
end initDeck ; 
proc initTable ; 
in def i64 ?__pkt ; 
begin ; 
global :: initDeck ?deck ; 
call initDeck ( ) ; 
def i32 ?i = call rand_uint_range ( 300 ) ; 
jmp .whilecmp11 ; 
label .while11 ; 
call shuffle ( ?deck ) ; 
-- ?i ; 
label .whilecmp11 ; 
jmpc .while11 ?i ; 
static def i80 ?playercards ; 
def i64 ?anonptr = & ?playercards ; 
@ offset 2 i64 ?__pkt = ?anonptr ; 
static def i80 ?dealercards ; 
?anonptr = & ?dealercards ; 
@ offset 14 i64 ?__pkt = ?anonptr ; 
def i8 ?card = 0 ; 
def i8 ?byte = 0 ; 
@ offset 10 i8 ?__pkt = ?card ; 
@ offset 22 i8 ?__pkt = ?card ; 
?card = call Deck@pullcard ( & ?deck ) ; 
@ offset 0 i8 ?__pkt = ?card ; 
?card = call Deck@pullcard ( & ?deck ) ; 
@ offset 1 i8 ?__pkt = ?card ; 
def i64 ?arr = ?__pkt ; 
call countCardTotal ( ?arr ) ; 
?card = call Deck@pullcard ( & ?deck ) ; 
@ offset 12 i8 ?__pkt = ?card ; 
?card = call Deck@pullcard ( & ?deck ) ; 
@ offset 13 i8 ?__pkt = ?card ; 
?arr = ?__pkt ; 
?arr = + i64 i32 ?arr 12 ; 
call countCardTotal ( ?arr ) ; 
end initTable ; 
proc main ; 
begin ; 
global :: initDeck ?deck ; 
call __rand_scope ( ) ; 
def i192 ?pkt ; 
subset i8 0 ?pkt.playerCard1 ?pkt ; 
subset i8 1 ?pkt.playerCard2 ?pkt ; 
subset i64 2 ?pkt.AdditionalPlayerCards ?pkt ; 
subset i8 10 ?pkt.AdditionalPlayerCardCount ?pkt ; 
subset i8 11 ?pkt.playerCardTotal ?pkt ; 
subset i8 12 ?pkt.dealerCard1 ?pkt ; 
subset i8 13 ?pkt.dealerCard2 ?pkt ; 
subset i64 14 ?pkt.AdditionalDealerCards ?pkt ; 
subset i8 22 ?pkt.AdditionalDealerCardCount ?pkt ; 
subset i8 23 ?pkt.dealerCardTotal ?pkt ; 
def i64 ?__pkt = & ?pkt ; 
call initTable ( ?__pkt ) ; 
def i32 ?x = 0 ; 
def i32 ?i = 0 ; 
static def i128 ?prompt1 = "Your cards are: " ; 
static def i40 ?prompt2 = " and " ; 
call prints ( 1 ?prompt1 ) ; 
?x = ?pkt.playerCard1 ; 
call printu ( 1 ?x ) ; 
call prints ( 1 ?prompt2 ) ; 
?x = ?pkt.playerCard2 ; 
call printu ( 1 ?x ) ; 
call printc ( 1 10 ) ; 
static def i328 ?prompt3 = "The dealer has 2 cards. One of them is a " ; 
?x = ?pkt.dealerCard1 ; 
call prints ( 1 ?prompt3 ) ; 
call printu ( 1 ?x ) ; 
call printc ( 1 10 ) ; 
def i8 ?gameNotOver = true ; 
jmp .whilecmp12 ; 
label .while12 ; 
static def i200 ?prompt4 = "Do you 'hit' or 'stand'? " ; 
call prints ( 1 ?prompt4 ) ; 
static def i240 ?buffer ; 
def i64 ?__buffer = & ?buffer ; 
def i32 ?strLength = call readf ( 1 ?buffer 30 ) ; 
-- ?strLength ; 
?__buffer = + i64 i32 ?__buffer ?strLength ; 
@ ?__buffer i32 0 ; 
static def i24 ?hit = "hit" ; 
static def i40 ?stand = "stand" ; 
def i8 ?eqToHit = call strcmp ( ?buffer ?hit ) ; 
def i8 ?eqToStand = call strcmp ( ?buffer ?stand ) ; 
static def i144 ?hitprompt = "you hit and got a " ; 
static def i88 ?standprompt = "you stood\n" ; 
jmpc .if18 ! ?eqToHit ; 
call prints ( 1 ?hitprompt ) ; 
def i8 ?card = call Deck@pullcard ( & ?deck ) ; 
call addCardToPlayerHand ( ?__pkt ?card ) ; 
?i = ?card ; 
jmpc .if19 ! == i32 i32 ?i 1 ; 
call printc ( 1 "A" ) ; 
jmp .escape27 ; 
label .if19 ; 
call printu ( 1 ?i ) ; 
label .escape27 ; 
call printc ( 1 10 ) ; 
label .if18 ; 
jmpc .if20 ! ?eqToStand ; 
call prints ( 1 ?standprompt ) ; 
?gameNotOver = false ; 
label .if20 ; 
def i8 ?playerCardTotal = ?pkt.playerCardTotal ; 
jmpc .if21 ! >= i8 i32 ?playerCardTotal 21 ; 
?gameNotOver = false ; 
label .if21 ; 
label .whilecmp12 ; 
jmpc .while12 ?gameNotOver ; 
def i8 ?dealerCardTotal = ?pkt.dealerCardTotal ; 
jmp .whilecmp13 ; 
label .while13 ; 
def i8 ?card = call Deck@pullcard ( & ?deck ) ; 
call addCardToDealerHand ( ?__pkt ?card ) ; 
?dealerCardTotal = ?pkt.dealerCardTotal ; 
label .whilecmp13 ; 
jmpc .while13 < i8 i32 ?dealerCardTotal 16 ; 
static def i232 ?bothbust = "You both busted, its a tie.\n" ; 
static def i208 ?youbust = "You busted, you lose >:(\n" ; 
static def i248 ?dealerbust = "The dealer busted, you win :D\n" ; 
static def i80 ?youwin = "You win!\n" ; 
static def i104 ?youlose = "You lose :(\n" ; 
static def i112 ?tie = "Its a tie :/\n" ; 
def i32 ?pct = ?pkt.playerCardTotal ; 
def i32 ?dct = ?pkt.dealerCardTotal ; 
jmpc .if22 ! > i32 i32 ?pct 21 ; 
jmpc .if23 ! > i32 i32 ?dct 21 ; 
call prints ( 1 ?bothbust ) ; 
jmp .escape31 ; 
label .if23 ; 
call prints ( 1 ?youbust ) ; 
label .escape31 ; 
jmp .escape30 ; 
label .if22 ; 
jmpc .elif129 ! > i32 i32 ?dct 21 ; 
call prints ( 1 ?dealerbust ) ; 
jmp .escape30 ; 
label .elif129 ; 
jmpc .elif130 ! > i32 i32 ?pct ?dct ; 
call prints ( 1 ?youwin ) ; 
jmp .escape30 ; 
label .elif130 ; 
jmpc .elif131 ! == i32 i32 ?pct ?dct ; 
call prints ( 1 ?tie ) ; 
jmp .escape30 ; 
label .elif131 ; 
jmpc .elif132 ! > i32 i32 ?dct ?pct ; 
call prints ( 1 ?youlose ) ; 
label .escape30 ; 
label .elif132 ; 
call displayHands ( ?__pkt ) ; 
end main ; 
