proc SYS_write ; 
in def i32 ?fd ; 
in def i64 ?buffer ; 
in def i32 ?size ; 
out def i32 ?write_amount ; 
begin ; 
?write_amount = syscall ( 1 ?fd ?buffer ?size ) ; 
end SYS_write ; 
proc SYS_read ; 
in def i32 ?fd ; 
in def i64 ?buffer ; 
in def i32 ?size ; 
out def i32 ?read_amount ; 
begin ; 
?read_amount = syscall ( 0 ?fd ?buffer ?size ) ; 
end SYS_read ; 
proc SYS_openfd ; 
in def i64 ?filename ; 
in def i32 ?flags ; 
in def i32 ?mode ; 
out def i32 ?fd ; 
begin ; 
?fd = syscall ( 2 ?filename ?flags ?mode ) ; 
end SYS_openfd ; 
proc SYS_closefd ; 
in def i32 ?fd ; 
begin ; 
syscall ( 3 ?fd ) ; 
end SYS_closefd ; 
proc SYS_fstat ; 
in def i32 ?fd ; 
in def i64 ?fstat_struct ; 
begin ; 
syscall ( 5 ?fd ?fstat_struct ) ; 
end SYS_fstat ; 
proc SYS_exit ; 
in def i32 ?error_code ; 
begin ; 
syscall ( 60 ?error_code ) ; 
end SYS_exit ; 
proc sizeof_file ; 
in def i32 ?fd ; 
out def i32 ?size ; 
begin ; 
def i1152 ?fstat_struct ; 
def i64 ?y = & ?fstat_struct ; 
call SYS_fstat ( ?fd ?y ) ; 
?y = + i64 i32 ?y 48 ; 
?size = @ ?y ; 
end sizeof_file ; 
proc printc ; 
in def i32 ?fd ; 
in def i8 ?x ; 
out def i32 ?err ; 
begin ; 
def i64 ?y = & ?x ; 
?err = call SYS_write ( ?fd ?y 1 ) ; 
end printc ; 
proc strlen ; 
in def i64 ?str ; 
out def i32 ?len ; 
begin ; 
def i64 ?beginning = ?str ; 
def i8 ?c = @ ?str ; 
jmp .whilecmp1 ; 
label .while1 ; 
++ ?str ; 
?c = @ ?str ; 
label .whilecmp1 ; 
jmpc .while1 ?c ; 
?len = - i64 i64 ?str ?beginning ; 
end strlen ; 
proc strcmp ; 
in def i64 ?str1 ; 
in def i64 ?str2 ; 
out def i8 ?equals? ; 
begin ; 
def i32 ?len1 = call strlen ( ?str1 ) ; 
def i32 ?len2 = call strlen ( ?str2 ) ; 
?equals? = == i32 i32 ?len1 ?len2 ; 
jmpc .if1 ! ?equals? ; 
def i8 ?continue = true ; 
def i8 ?i = 0 ; 
jmp .whilecmp2 ; 
label .while2 ; 
def i8 ?c1 = @ ?str1 ; 
def i8 ?c2 = @ ?str2 ; 
?equals? = == i8 i8 ?c1 ?c2 ; 
def i8 ?nend = < i8 i32 ?i ?len1 ; 
?continue = && i8 i8 ?equals? ?nend ; 
++ ?i ; 
++ ?str1 ; 
++ ?str2 ; 
label .whilecmp2 ; 
jmpc .while2 ?continue ; 
label .if1 ; 
end strcmp ; 
proc strcpy ; 
in def i64 ?source ; 
in def i64 ?dest ; 
begin ; 
def i8 ?c = @ ?source ; 
jmp .whilecmp3 ; 
label .while3 ; 
@ ?dest i8 ?c ; 
++ ?source ; 
++ ?dest ; 
?c = @ ?source ; 
label .whilecmp3 ; 
jmpc .while3 ?c ; 
@ ?dest i32 0 ; 
end strcpy ; 
proc prints ; 
in def i32 ?fd ; 
in def i64 ?str ; 
out def i32 ?err ; 
begin ; 
def i32 ?len = call strlen ( ?str ) ; 
?err = call SYS_write ( ?fd ?str ?len ) ; 
end prints ; 
proc __print_error ; 
in def i32 ?error ; 
begin ; 
?error = - i32 i32 4294967294 ?error ; 
?error = + i32 i32 ?error 2 ; 
def i2048 ?error_msg ; 
def i64 ?eptr = & ?error_msg ; 
def i64 ?null = 0 ; 
def i32 ?i = 0 ; 
jmp .whilecmp4 ; 
label .while4 ; 
@ ?eptr i64 ?null ; 
?eptr = + i64 i32 ?eptr 8 ; 
?i = + i32 i32 ?i 8 ; 
label .whilecmp4 ; 
jmpc .while4 < i32 i32 ?i 256 ; 
?eptr = & ?error_msg ; 
jmpc .if2 ! == i32 i32 ?error 1 ; 
?error_msg = "Operation not permitted." ; 
jmp .escape4 ; 
label .if2 ; 
jmpc .elif1 ! == i32 i32 ?error 2 ; 
?error_msg = "No such file or directory." ; 
jmp .escape4 ; 
label .elif1 ; 
jmpc .elif2 ! == i32 i32 ?error 3 ; 
?error_msg = "No such process." ; 
jmp .escape4 ; 
label .elif2 ; 
jmpc .elif3 ! == i32 i32 ?error 4 ; 
?error_msg = "Interrupted system call." ; 
jmp .escape4 ; 
label .elif3 ; 
jmpc .elif4 ! == i32 i32 ?error 5 ; 
?error_msg = "I/O error." ; 
jmp .escape4 ; 
label .elif4 ; 
jmpc .elif5 ! == i32 i32 ?error 6 ; 
?error_msg = "No such device or address." ; 
jmp .escape4 ; 
label .elif5 ; 
jmpc .elif6 ! == i32 i32 ?error 7 ; 
?error_msg = "Argument list too long." ; 
jmp .escape4 ; 
label .elif6 ; 
jmpc .elif7 ! == i32 i32 ?error 8 ; 
?error_msg = "Exec format error." ; 
jmp .escape4 ; 
label .elif7 ; 
jmpc .elif8 ! == i32 i32 ?error 9 ; 
?error_msg = "Bad file number." ; 
jmp .escape4 ; 
label .elif8 ; 
jmpc .elif9 ! == i32 i32 ?error 10 ; 
?error_msg = "No child processes." ; 
jmp .escape4 ; 
label .elif9 ; 
jmpc .elif10 ! == i32 i32 ?error 11 ; 
?error_msg = "Try again." ; 
jmp .escape4 ; 
label .elif10 ; 
jmpc .elif11 ! == i32 i32 ?error 12 ; 
?error_msg = "Out of memory." ; 
jmp .escape4 ; 
label .elif11 ; 
jmpc .elif12 ! == i32 i32 ?error 13 ; 
?error_msg = "Permission denied." ; 
jmp .escape4 ; 
label .elif12 ; 
jmpc .elif13 ! == i32 i32 ?error 14 ; 
?error_msg = "Bad address." ; 
jmp .escape4 ; 
label .elif13 ; 
jmpc .elif14 ! == i32 i32 ?error 15 ; 
?error_msg = "Block device required." ; 
jmp .escape4 ; 
label .elif14 ; 
jmpc .elif15 ! == i32 i32 ?error 16 ; 
?error_msg = "Device or resource busy." ; 
jmp .escape4 ; 
label .elif15 ; 
jmpc .elif16 ! == i32 i32 ?error 17 ; 
?error_msg = "File exists." ; 
jmp .escape4 ; 
label .elif16 ; 
jmpc .elif17 ! == i32 i32 ?error 18 ; 
?error_msg = "Cross-device link." ; 
jmp .escape4 ; 
label .elif17 ; 
jmpc .elif18 ! == i32 i32 ?error 19 ; 
?error_msg = "No such device." ; 
jmp .escape4 ; 
label .elif18 ; 
jmpc .elif19 ! == i32 i32 ?error 20 ; 
?error_msg = "Not a directory." ; 
jmp .escape4 ; 
label .elif19 ; 
jmpc .elif20 ! == i32 i32 ?error 21 ; 
?error_msg = "Is a directory." ; 
jmp .escape4 ; 
label .elif20 ; 
jmpc .elif21 ! == i32 i32 ?error 22 ; 
?error_msg = "Invalid argument." ; 
jmp .escape4 ; 
label .elif21 ; 
jmpc .elif22 ! == i32 i32 ?error 23 ; 
?error_msg = "File table overflow." ; 
jmp .escape4 ; 
label .elif22 ; 
jmpc .elif23 ! == i32 i32 ?error 24 ; 
?error_msg = "Too many open files." ; 
jmp .escape4 ; 
label .elif23 ; 
jmpc .elif24 ! == i32 i32 ?error 25 ; 
?error_msg = "Not a typewriter." ; 
jmp .escape4 ; 
label .elif24 ; 
jmpc .elif25 ! == i32 i32 ?error 26 ; 
?error_msg = "Text file busy." ; 
jmp .escape4 ; 
label .elif25 ; 
jmpc .elif26 ! == i32 i32 ?error 27 ; 
?error_msg = "File too large." ; 
jmp .escape4 ; 
label .elif26 ; 
jmpc .elif27 ! == i32 i32 ?error 28 ; 
?error_msg = "No space left on device." ; 
jmp .escape4 ; 
label .elif27 ; 
jmpc .elif28 ! == i32 i32 ?error 29 ; 
?error_msg = "Illegal seek." ; 
jmp .escape4 ; 
label .elif28 ; 
jmpc .elif29 ! == i32 i32 ?error 30 ; 
?error_msg = "Read-only file system." ; 
jmp .escape4 ; 
label .elif29 ; 
jmpc .elif30 ! == i32 i32 ?error 31 ; 
?error_msg = "Too many links." ; 
jmp .escape4 ; 
label .elif30 ; 
jmpc .elif31 ! == i32 i32 ?error 32 ; 
?error_msg = "Broken pipe." ; 
jmp .escape4 ; 
label .elif31 ; 
jmpc .elif32 ! == i32 i32 ?error 33 ; 
?error_msg = "Math argument out of domain of func." ; 
jmp .escape4 ; 
label .elif32 ; 
jmpc .elif33 ! == i32 i32 ?error 34 ; 
?error_msg = "Math result not representable." ; 
jmp .escape4 ; 
label .elif33 ; 
jmpc .elif34 ! == i32 i32 ?error 35 ; 
?error_msg = "Resource deadlock would occur." ; 
jmp .escape4 ; 
label .elif34 ; 
jmpc .elif35 ! == i32 i32 ?error 36 ; 
?error_msg = "File name too long." ; 
jmp .escape4 ; 
label .elif35 ; 
jmpc .elif36 ! == i32 i32 ?error 37 ; 
?error_msg = "No record locks available." ; 
jmp .escape4 ; 
label .elif36 ; 
jmpc .elif37 ! == i32 i32 ?error 38 ; 
?error_msg = "Function not implemented." ; 
jmp .escape4 ; 
label .elif37 ; 
jmpc .elif38 ! == i32 i32 ?error 39 ; 
?error_msg = "Directory not empty." ; 
jmp .escape4 ; 
label .elif38 ; 
jmpc .elif39 ! == i32 i32 ?error 40 ; 
?error_msg = "Too many symbolic links encountered." ; 
jmp .escape4 ; 
label .elif39 ; 
jmpc .elif40 ! == i32 i32 ?error 42 ; 
?error_msg = "No message of desired type." ; 
jmp .escape4 ; 
label .elif40 ; 
jmpc .elif41 ! == i32 i32 ?error 43 ; 
?error_msg = "Identifier removed." ; 
jmp .escape4 ; 
label .elif41 ; 
jmpc .elif42 ! == i32 i32 ?error 44 ; 
?error_msg = "Channel number out of range." ; 
jmp .escape4 ; 
label .elif42 ; 
jmpc .elif43 ! == i32 i32 ?error 45 ; 
?error_msg = "Level 2 not synchronized." ; 
jmp .escape4 ; 
label .elif43 ; 
jmpc .elif44 ! == i32 i32 ?error 46 ; 
?error_msg = "Level 3 halted." ; 
jmp .escape4 ; 
label .elif44 ; 
jmpc .elif45 ! == i32 i32 ?error 47 ; 
?error_msg = "Level 3 reset." ; 
jmp .escape4 ; 
label .elif45 ; 
jmpc .elif46 ! == i32 i32 ?error 48 ; 
?error_msg = "Link number out of range." ; 
jmp .escape4 ; 
label .elif46 ; 
jmpc .elif47 ! == i32 i32 ?error 49 ; 
?error_msg = "Protocol driver not attached." ; 
jmp .escape4 ; 
label .elif47 ; 
jmpc .elif48 ! == i32 i32 ?error 50 ; 
?error_msg = "No CSI structure available." ; 
jmp .escape4 ; 
label .elif48 ; 
jmpc .elif49 ! == i32 i32 ?error 51 ; 
?error_msg = "Level 2 halted." ; 
jmp .escape4 ; 
label .elif49 ; 
jmpc .elif50 ! == i32 i32 ?error 52 ; 
?error_msg = "Invalid exchange." ; 
jmp .escape4 ; 
label .elif50 ; 
jmpc .elif51 ! == i32 i32 ?error 53 ; 
?error_msg = "Invalid request descriptor." ; 
jmp .escape4 ; 
label .elif51 ; 
jmpc .elif52 ! == i32 i32 ?error 54 ; 
?error_msg = "Exchange full." ; 
jmp .escape4 ; 
label .elif52 ; 
jmpc .elif53 ! == i32 i32 ?error 55 ; 
?error_msg = "No anode." ; 
jmp .escape4 ; 
label .elif53 ; 
jmpc .elif54 ! == i32 i32 ?error 56 ; 
?error_msg = "Invalid request code." ; 
jmp .escape4 ; 
label .elif54 ; 
jmpc .elif55 ! == i32 i32 ?error 57 ; 
?error_msg = "Invalid slot." ; 
jmp .escape4 ; 
label .elif55 ; 
jmpc .elif56 ! == i32 i32 ?error 59 ; 
?error_msg = "Bad font file format." ; 
jmp .escape4 ; 
label .elif56 ; 
jmpc .elif57 ! == i32 i32 ?error 60 ; 
?error_msg = "Device not a stream." ; 
jmp .escape4 ; 
label .elif57 ; 
jmpc .elif58 ! == i32 i32 ?error 61 ; 
?error_msg = "No data available." ; 
jmp .escape4 ; 
label .elif58 ; 
jmpc .elif59 ! == i32 i32 ?error 62 ; 
?error_msg = "Timer expired." ; 
jmp .escape4 ; 
label .elif59 ; 
jmpc .elif60 ! == i32 i32 ?error 63 ; 
?error_msg = "Out of streams resources." ; 
jmp .escape4 ; 
label .elif60 ; 
jmpc .elif61 ! == i32 i32 ?error 64 ; 
?error_msg = "Machine is not on the network." ; 
jmp .escape4 ; 
label .elif61 ; 
jmpc .elif62 ! == i32 i32 ?error 65 ; 
?error_msg = "Package not installed." ; 
jmp .escape4 ; 
label .elif62 ; 
jmpc .elif63 ! == i32 i32 ?error 66 ; 
?error_msg = "Object is remote." ; 
jmp .escape4 ; 
label .elif63 ; 
jmpc .elif64 ! == i32 i32 ?error 67 ; 
?error_msg = "Link has been severed." ; 
jmp .escape4 ; 
label .elif64 ; 
jmpc .elif65 ! == i32 i32 ?error 68 ; 
?error_msg = "Advertise error." ; 
jmp .escape4 ; 
label .elif65 ; 
jmpc .elif66 ! == i32 i32 ?error 69 ; 
?error_msg = "Srmount error." ; 
jmp .escape4 ; 
label .elif66 ; 
jmpc .elif67 ! == i32 i32 ?error 70 ; 
?error_msg = "Communication error on send." ; 
jmp .escape4 ; 
label .elif67 ; 
jmpc .elif68 ! == i32 i32 ?error 71 ; 
?error_msg = "Protocol error." ; 
jmp .escape4 ; 
label .elif68 ; 
jmpc .elif69 ! == i32 i32 ?error 72 ; 
?error_msg = "Multihop attempted." ; 
jmp .escape4 ; 
label .elif69 ; 
jmpc .elif70 ! == i32 i32 ?error 73 ; 
?error_msg = "RFS specific error." ; 
jmp .escape4 ; 
label .elif70 ; 
jmpc .elif71 ! == i32 i32 ?error 74 ; 
?error_msg = "Not a data message." ; 
jmp .escape4 ; 
label .elif71 ; 
jmpc .elif72 ! == i32 i32 ?error 75 ; 
?error_msg = "Value too large for defined data type." ; 
jmp .escape4 ; 
label .elif72 ; 
jmpc .elif73 ! == i32 i32 ?error 76 ; 
?error_msg = "Name not unique on network." ; 
jmp .escape4 ; 
label .elif73 ; 
jmpc .elif74 ! == i32 i32 ?error 77 ; 
?error_msg = "File descriptor in bad state." ; 
jmp .escape4 ; 
label .elif74 ; 
jmpc .elif75 ! == i32 i32 ?error 78 ; 
?error_msg = "Remote address changed." ; 
jmp .escape4 ; 
label .elif75 ; 
jmpc .elif76 ! == i32 i32 ?error 79 ; 
?error_msg = "Can not access a needed shared library." ; 
jmp .escape4 ; 
label .elif76 ; 
jmpc .elif77 ! == i32 i32 ?error 80 ; 
?error_msg = "Accessing a corrupted shared library." ; 
jmp .escape4 ; 
label .elif77 ; 
jmpc .elif78 ! == i32 i32 ?error 81 ; 
?error_msg = "lib section in a out corrupted." ; 
jmp .escape4 ; 
label .elif78 ; 
jmpc .elif79 ! == i32 i32 ?error 82 ; 
?error_msg = "Attempting to link in too many shared libraries." ; 
jmp .escape4 ; 
label .elif79 ; 
jmpc .elif80 ! == i32 i32 ?error 83 ; 
?error_msg = "Cannot exec a shared library directly." ; 
jmp .escape4 ; 
label .elif80 ; 
jmpc .elif81 ! == i32 i32 ?error 84 ; 
?error_msg = "Illegal byte sequence." ; 
jmp .escape4 ; 
label .elif81 ; 
jmpc .elif82 ! == i32 i32 ?error 85 ; 
?error_msg = "Interrupted system call should be restarted." ; 
jmp .escape4 ; 
label .elif82 ; 
jmpc .elif83 ! == i32 i32 ?error 86 ; 
?error_msg = "Streams pipe error." ; 
jmp .escape4 ; 
label .elif83 ; 
jmpc .elif84 ! == i32 i32 ?error 87 ; 
?error_msg = "Too many users." ; 
jmp .escape4 ; 
label .elif84 ; 
jmpc .elif85 ! == i32 i32 ?error 88 ; 
?error_msg = "Socket operation on non-socket." ; 
jmp .escape4 ; 
label .elif85 ; 
jmpc .elif86 ! == i32 i32 ?error 89 ; 
?error_msg = "Destination address required." ; 
jmp .escape4 ; 
label .elif86 ; 
jmpc .elif87 ! == i32 i32 ?error 90 ; 
?error_msg = "Message too long." ; 
jmp .escape4 ; 
label .elif87 ; 
jmpc .elif88 ! == i32 i32 ?error 91 ; 
?error_msg = "Protocol wrong type for socket." ; 
jmp .escape4 ; 
label .elif88 ; 
jmpc .elif89 ! == i32 i32 ?error 92 ; 
?error_msg = "Protocol not available." ; 
jmp .escape4 ; 
label .elif89 ; 
jmpc .elif90 ! == i32 i32 ?error 93 ; 
?error_msg = "Protocol not supported." ; 
jmp .escape4 ; 
label .elif90 ; 
jmpc .elif91 ! == i32 i32 ?error 94 ; 
?error_msg = "Socket type not supported." ; 
jmp .escape4 ; 
label .elif91 ; 
jmpc .elif92 ! == i32 i32 ?error 95 ; 
?error_msg = "Operation not supported on transport endpoint." ; 
jmp .escape4 ; 
label .elif92 ; 
jmpc .elif93 ! == i32 i32 ?error 96 ; 
?error_msg = "Protocol family not supported." ; 
jmp .escape4 ; 
label .elif93 ; 
jmpc .elif94 ! == i32 i32 ?error 97 ; 
?error_msg = "Address family not supported by protocol." ; 
jmp .escape4 ; 
label .elif94 ; 
jmpc .elif95 ! == i32 i32 ?error 98 ; 
?error_msg = "Address already in use." ; 
jmp .escape4 ; 
label .elif95 ; 
jmpc .elif96 ! == i32 i32 ?error 99 ; 
?error_msg = "Cannot assign requested address." ; 
jmp .escape4 ; 
label .elif96 ; 
jmpc .elif97 ! == i32 i32 ?error 100 ; 
?error_msg = "Network is down." ; 
jmp .escape4 ; 
label .elif97 ; 
jmpc .elif98 ! == i32 i32 ?error 101 ; 
?error_msg = "Network is unreachable." ; 
jmp .escape4 ; 
label .elif98 ; 
jmpc .elif99 ! == i32 i32 ?error 102 ; 
?error_msg = "Network dropped connection because of reset." ; 
jmp .escape4 ; 
label .elif99 ; 
jmpc .elif100 ! == i32 i32 ?error 103 ; 
?error_msg = "Software caused connection abort." ; 
jmp .escape4 ; 
label .elif100 ; 
jmpc .elif101 ! == i32 i32 ?error 104 ; 
?error_msg = "Connection reset by peer." ; 
jmp .escape4 ; 
label .elif101 ; 
jmpc .elif102 ! == i32 i32 ?error 105 ; 
?error_msg = "No buffer space available." ; 
jmp .escape4 ; 
label .elif102 ; 
jmpc .elif103 ! == i32 i32 ?error 106 ; 
?error_msg = "Transport endpoint is already connected." ; 
jmp .escape4 ; 
label .elif103 ; 
jmpc .elif104 ! == i32 i32 ?error 107 ; 
?error_msg = "Transport endpoint is not connected." ; 
jmp .escape4 ; 
label .elif104 ; 
jmpc .elif105 ! == i32 i32 ?error 108 ; 
?error_msg = "Cannot send after transport endpoint shutdown." ; 
jmp .escape4 ; 
label .elif105 ; 
jmpc .elif106 ! == i32 i32 ?error 109 ; 
?error_msg = "Too many references: cannot splice." ; 
jmp .escape4 ; 
label .elif106 ; 
jmpc .elif107 ! == i32 i32 ?error 110 ; 
?error_msg = "Connection timed out." ; 
jmp .escape4 ; 
label .elif107 ; 
jmpc .elif108 ! == i32 i32 ?error 111 ; 
?error_msg = "Connection refused." ; 
jmp .escape4 ; 
label .elif108 ; 
jmpc .elif109 ! == i32 i32 ?error 112 ; 
?error_msg = "Host is down." ; 
jmp .escape4 ; 
label .elif109 ; 
jmpc .elif110 ! == i32 i32 ?error 113 ; 
?error_msg = "No route to host." ; 
jmp .escape4 ; 
label .elif110 ; 
jmpc .elif111 ! == i32 i32 ?error 114 ; 
?error_msg = "Operation already in progress." ; 
jmp .escape4 ; 
label .elif111 ; 
jmpc .elif112 ! == i32 i32 ?error 115 ; 
?error_msg = "Operation now in progress." ; 
jmp .escape4 ; 
label .elif112 ; 
jmpc .elif113 ! == i32 i32 ?error 116 ; 
?error_msg = "Stale NFS file handle." ; 
jmp .escape4 ; 
label .elif113 ; 
jmpc .elif114 ! == i32 i32 ?error 117 ; 
?error_msg = "Structure needs cleaning." ; 
jmp .escape4 ; 
label .elif114 ; 
jmpc .elif115 ! == i32 i32 ?error 118 ; 
?error_msg = "Not a XENIX named type file." ; 
jmp .escape4 ; 
label .elif115 ; 
jmpc .elif116 ! == i32 i32 ?error 119 ; 
?error_msg = "No XENIX semaphores available." ; 
jmp .escape4 ; 
label .elif116 ; 
jmpc .elif117 ! == i32 i32 ?error 120 ; 
?error_msg = "Is a named type file." ; 
jmp .escape4 ; 
label .elif117 ; 
jmpc .elif118 ! == i32 i32 ?error 121 ; 
?error_msg = "Remote I/O error." ; 
jmp .escape4 ; 
label .elif118 ; 
jmpc .elif119 ! == i32 i32 ?error 122 ; 
?error_msg = "Quota exceeded." ; 
jmp .escape4 ; 
label .elif119 ; 
jmpc .elif120 ! == i32 i32 ?error 123 ; 
?error_msg = "No medium found." ; 
jmp .escape4 ; 
label .elif120 ; 
jmpc .elif121 ! == i32 i32 ?error 124 ; 
?error_msg = "Wrong medium type." ; 
jmp .escape4 ; 
label .elif121 ; 
jmpc .elif122 ! == i32 i32 ?error 125 ; 
?error_msg = "Operation Canceled." ; 
jmp .escape4 ; 
label .elif122 ; 
jmpc .elif123 ! == i32 i32 ?error 126 ; 
?error_msg = "Required key not available." ; 
jmp .escape4 ; 
label .elif123 ; 
jmpc .elif124 ! == i32 i32 ?error 127 ; 
?error_msg = "Key has expired." ; 
jmp .escape4 ; 
label .elif124 ; 
jmpc .elif125 ! == i32 i32 ?error 128 ; 
?error_msg = "Key has been revoked." ; 
jmp .escape4 ; 
label .elif125 ; 
jmpc .elif126 ! == i32 i32 ?error 129 ; 
?error_msg = "Key was rejected by service." ; 
jmp .escape4 ; 
label .elif126 ; 
jmpc .elif127 ! == i32 i32 ?error 130 ; 
?error_msg = "Owner died." ; 
jmp .escape4 ; 
label .elif127 ; 
jmpc .elif128 ! == i32 i32 ?error 131 ; 
?error_msg = "State not recoverable." ; 
label .escape4 ; 
label .elif128 ; 
?eptr = & ?error_msg ; 
call prints ( 2 ?eptr ) ; 
end __print_error ; 
proc readf ; 
in def i32 ?fd ; 
in def i64 ?buffer ; 
in def i32 ?length ; 
out def i32 ?len ; 
begin ; 
?length = call SYS_read ( ?fd ?buffer ?length ) ; 
jmpc .if3 ! < i32 i32 ?length 0 ; 
def i8 ?newline = 10 ; 
def i160 ?error = "Unable to read file." ; 
def i64 ?mp = & ?error ; 
call SYS_write ( 2 ?mp 21 ) ; 
def i56 ?msg = "Error: " ; 
?mp = & ?msg ; 
call SYS_write ( 2 ?mp 7 ) ; 
call __print_error ( ?length ) ; 
call printc ( 2 ?newline ) ; 
call SYS_exit ( 1 ) ; 
label .if3 ; 
?len = ?length ; 
end readf ; 
proc openf ; 
in def i64 ?filename ; 
out def i32 ?fd ; 
begin ; 
?fd = call SYS_openfd ( ?filename 2 1792 ) ; 
jmpc .if4 ! < i32 i32 ?fd 0 ; 
def i8 ?newline = 10 ; 
def i160 ?error = "Unable to open file." ; 
def i64 ?mp = & ?error ; 
call SYS_write ( 2 ?mp 21 ) ; 
def i56 ?msg = "Error: " ; 
?mp = & ?msg ; 
call SYS_write ( 2 ?mp 7 ) ; 
call __print_error ( ?fd ) ; 
call printc ( 2 ?newline ) ; 
call SYS_exit ( 1 ) ; 
label .if4 ; 
end openf ; 
proc mmap ; 
in def i64 ?addr ; 
in def i32 ?length ; 
in def i32 ?prot ; 
in def i32 ?flags ; 
in def i32 ?fd ; 
in def i32 ?offset ; 
out def i64 ?ret_addr ; 
begin ; 
?ret_addr = syscall ( 9 ?addr ?length ?prot ?flags ?fd ?offset ) ; 
jmpc .if5 ! < i64 i32 ?ret_addr 0 ; 
def i8 ?null = 0 ; 
def i160 ?error = "Couldn't map memory." ; 
def i64 ?__error = & ?error ; 
call prints ( 2 ?__error ) ; 
call printc ( 2 10 ) ; 
call __print_error ( ?ret_addr ) ; 
call printc ( 2 10 ) ; 
call SYS_exit ( 1 ) ; 
label .if5 ; 
end mmap ; 
proc munmap ; 
in def i64 ?addr ; 
in def i32 ?length ; 
begin ; 
def i32 ?err = syscall ( 11 ?addr ?length ) ; 
jmpc .if6 ! < i32 i32 ?err 0 ; 
def i8 ?null = 0 ; 
def i176 ?error = "Couldn't unmap memory." ; 
def i64 ?__error = & ?error ; 
call prints ( 2 ?__error ) ; 
call printc ( 2 10 ) ; 
call __print_error ( ?err ) ; 
call printc ( 2 10 ) ; 
call SYS_exit ( 1 ) ; 
label .if6 ; 
end munmap ; 
proc dynamic_string@init ; 
in def i64 ?self ; 
in def i32 ?nsize ; 
in def i32 ?nsize_step ; 
begin ; 
def i8 ?nullterm = 0 ; 
jmpc .if7 ! < i32 i32 ?nsize 1 ; 
def i8 ?newline = 10 ; 
def i304 ?msg = "ERROR: invalid size for dynamic_string" ; 
def i64 ?__msg = & ?msg ; 
call prints ( 2 ?__msg ) ; 
call SYS_exit ( 1 ) ; 
jmp .escape14 ; 
label .if7 ; 
def i32 ?prot = | i32 i32 1 2 ; 
def i32 ?flags = | i32 i32 2 32 ; 
def i64 ?addr = call mmap ( 0 ?nsize ?prot ?flags 0 0 ) ; 
def i64 ?__self = ?self ; 
def i32 ?zero = 0 ; 
@ offset 0 i64 ?__self = ?addr ; 
@ offset 8 i32 ?__self = ?zero ; 
@ offset 12 i32 ?__self = ?nsize ; 
@ offset 16 i32 ?__self = ?nsize_step ; 
@ ?addr i8 ?nullterm ; 
label .escape14 ; 
def i8 ?contcon = < i32 i32 ?nsize_step 1 ; 
def i8 ?contcontemp = > i32 i32 ?nsize_step 1028 ; 
| i8 i8 ?contcon ?contcontemp ; 
jmpc .if8 ! ?contcon ; 
def i8 ?newline1 = 10 ; 
def i544 ?msg1 = "ERROR: Unreasonable size_step in dynamic_string.init(size size_step)" ; 
def i64 ?__msg1 = & ?msg1 ; 
call prints ( 2 ?__msg1 ) ; 
call SYS_exit ( 1 ) ; 
label .if8 ; 
end dynamic_string@init ; 
proc dynamic_string@free ; 
in def i64 ?self ; 
begin ; 
def i32 ?zero = 0 ; 
def i64 ?bigzero = 0 ; 
def i64 ?__self = ?self ; 
def i32 ?nsize = @ offset 12 i32 ?__self ; 
def i64 ?addr = @ offset 0 i64 ?__self ; 
call munmap ( ?addr ?nsize ) ; 
@ offset 12 i32 ?__self = ?zero ; 
@ offset 8 i32 ?__self = ?zero ; 
@ offset 0 i64 ?__self = ?bigzero ; 
end dynamic_string@free ; 
proc dynamic_string@appendbyte ; 
in def i64 ?self ; 
in def i8 ?byte ; 
begin ; 
def i64 ?__self = ?self ; 
def i32 ?newlength = @ offset 8 i32 ?__self ; 
?newlength = + i32 i32 ?newlength 2 ; 
def i32 ?size = @ offset 12 i32 ?__self ; 
jmpc .if9 ! > i32 i32 ?newlength ?size ; 
def i32 ?newsize = - i32 i32 ?newlength 1 ; 
def i32 ?size_step = @ offset 16 i32 ?__self ; 
?newsize = + i32 i32 ?newsize ?size_step ; 
def i32 ?prot = | i32 i32 1 2 ; 
def i32 ?flags = | i32 i32 2 32 ; 
def i64 ?newaddr = call mmap ( 0 ?newsize ?prot ?flags 0 0 ) ; 
def i32 ?oldsize = @ offset 12 i32 ?__self ; 
def i64 ?oldaddr = @ offset 0 i64 ?__self ; 
call strcpy ( ?oldaddr ?newaddr ) ; 
call munmap ( ?oldaddr ?oldsize ) ; 
@ offset 0 i64 ?__self = ?newaddr ; 
@ offset 12 i32 ?__self = ?newsize ; 
?newaddr = + i64 i32 ?newaddr ?newlength ; 
@ ?newaddr i32 0 ; 
label .if9 ; 
-- ?newlength ; 
@ offset 8 i32 ?__self = ?newlength ; 
def i64 ?writeAddr = @ offset 0 i64 ?__self ; 
?writeAddr = + i64 i32 ?writeAddr ?newlength ; 
-- ?writeAddr ; 
@ ?writeAddr i8 ?byte ; 
end dynamic_string@appendbyte ; 
proc str_is_number ; 
in def i64 ?strnullterm ; 
def i8 ?isNumber ; 
begin ; 
def i64 ?str = ?strnullterm ; 
def i8 ?c = @ ?str ; 
?isNumber = 1 ; 
jmp .whilecmp5 ; 
label .while5 ; 
jmpc .if10 ! < i8 i32 ?c 48 ; 
?isNumber = 0 ; 
jmp .escape21 ; 
label .if10 ; 
jmpc .elif129 ! > i8 i32 ?c 57 ; 
?isNumber = 0 ; 
label .escape21 ; 
label .elif129 ; 
++ ?str ; 
?c = @ ?str ; 
label .whilecmp5 ; 
jmpc .while5 ?c ; 
end str_is_number ; 
proc getIndexOfTokenMap ; 
in def i32 ?index ; 
out def i64 ?__data ; 
begin ; 
def i96 ?tkmappair ; 
subset i64 0 ?tkmappair.str ?tkmappair ; 
subset i32 8 ?tkmappair.type ?tkmappair ; 
?__data = & ?tkmappair ; 
jmpc .if11 ! == i32 i32 ?index 0 ; 
static def i8 ?add = "+" ; 
?tkmappair.str = & ?add ; 
?tkmappair.type = 25 ; 
jmp .escape22 ; 
label .if11 ; 
jmpc .elif130 ! == i32 i32 ?index 1 ; 
static def i8 ?sub = "-" ; 
?tkmappair.str = & ?sub ; 
?tkmappair.type = 26 ; 
jmp .escape22 ; 
label .elif130 ; 
?__data = 0 ; 
label .escape22 ; 
end getIndexOfTokenMap ; 
proc Token@init ; 
in def i64 ?self ; 
begin ; 
def i32 ?prot = | i32 i32 1 2 ; 
def i32 ?flags = | i32 i32 2 32 ; 
def i64 ?addr = call mmap ( 0 20 ?prot ?flags 0 0 ) ; 
def i64 ?__self = ?self ; 
@ offset 4 i64 ?__self = ?addr ; 
end Token@init ; 
proc Token@assignDstr ; 
in def i64 ?self ; 
in def i64 ?__dstr ; 
begin ; 
def i160 ?dstr ; 
subset i64 0 ?dstr.data ?dstr ; 
subset i32 8 ?dstr.length ?dstr ; 
subset i32 12 ?dstr.size ?dstr ; 
subset i32 16 ?dstr.size_step ?dstr ; 
?dstr = @ ?__dstr ; 
def i64 ?__self = ?self ; 
def i64 ?__dstrtyped = @ offset 4 i64 ?__self ; 
@ offset 0 i64 ?__dstrtyped = ?dstr.data ; 
@ offset 8 i32 ?__dstrtyped = ?dstr.length ; 
@ offset 12 i32 ?__dstrtyped = ?dstr.size ; 
@ offset 16 i32 ?__dstrtyped = ?dstr.size_step ; 
end Token@assignDstr ; 
proc Token@free ; 
in def i64 ?self ; 
begin ; 
def i64 ?__self = ?self ; 
def i64 ?__dstr = @ offset 4 i64 ?__self ; 
def i160 ?dstr ; 
subset i64 0 ?dstr.data ?dstr ; 
subset i32 8 ?dstr.length ?dstr ; 
subset i32 12 ?dstr.size ?dstr ; 
subset i32 16 ?dstr.size_step ?dstr ; 
?dstr = @ ?__dstr ; 
call dynamic_string@free ( & ?dstr ) ; 
call munmap ( ?__dstr 20 ) ; 
end Token@free ; 
proc idToken ; 
in def i64 ?__dstr ; 
out def i32 ?type ; 
begin ; 
?type = 0 ; 
def i160 ?dstr ; 
subset i64 0 ?dstr.data ?dstr ; 
subset i32 8 ?dstr.length ?dstr ; 
subset i32 12 ?dstr.size ?dstr ; 
subset i32 16 ?dstr.size_step ?dstr ; 
?dstr = @ ?__dstr ; 
def i64 ?bigzero = 0 ; 
def i32 ?i = 0 ; 
def i96 ?tkmappair ; 
subset i64 0 ?tkmappair.str ?tkmappair ; 
subset i32 8 ?tkmappair.type ?tkmappair ; 
def i64 ?__retstr = call getIndexOfTokenMap ( ?i ) ; 
?tkmappair = @ ?__retstr ; 
def i8 ?isMatch = 0 ; 
def i8 ?contcon = != i64 i64 ?__retstr ?bigzero ; 
jmp .whilecmp6 ; 
label .while6 ; 
def i64 ?__tkmappair = & ?tkmappair ; 
def i64 ?str = @ offset 0 i64 ?__tkmappair ; 
?isMatch = call strcmp ( ?dstr.data ?str ) ; 
++ ?i ; 
jmpc .if12 ! ?isMatch ; 
?type = ?tkmappair.type ; 
label .if12 ; 
?__retstr = call getIndexOfTokenMap ( ?i ) ; 
?contcon = != i64 i64 ?__retstr ?bigzero ; 
jmpc .if13 ! ?isMatch ; 
?contcon = 0 ; 
label .if13 ; 
jmpc .if14 ! ?contcon ; 
?tkmappair = @ ?__retstr ; 
label .if14 ; 
label .whilecmp6 ; 
jmpc .while6 ?contcon ; 
jmpc .if15 ! == i32 i32 ?type 0 ; 
def i8 ?isNumber = call str_is_number ( ?dstr.data ) ; 
jmpc .if16 ! ?isNumber ; 
?type = 2 ; 
label .if16 ; 
label .if15 ; 
jmpc .if17 ! == i32 i32 ?type 0 ; 
?type = 1 ; 
label .if17 ; 
end idToken ; 
proc getNextToken ; 
in def i64 ?endOfFile ; 
in def i64 ?__str ; 
out def i64 ?__tk ; 
begin ; 
def i160 ?dstr ; 
subset i64 0 ?dstr.data ?dstr ; 
subset i32 8 ?dstr.length ?dstr ; 
subset i32 12 ?dstr.size ?dstr ; 
subset i32 16 ?dstr.size_step ?dstr ; 
call dynamic_string@init ( & ?dstr 1 4 ) ; 
def i64 ?str = @ ?__str ; 
def i8 ?c = @ ?str ; 
def i8 ?contcon = != i64 i64 ?str ?endOfFile ; 
def i8 ?contcontemp = != i8 i8 ?c " " ; 
?contcon = && i8 i8 ?contcon ?contcontemp ; 
jmp .whilecmp7 ; 
label .while7 ; 
call dynamic_string@appendbyte ( & ?dstr ?c ) ; 
++ ?str ; 
?c = @ ?str ; 
?contcon = != i64 i64 ?str ?endOfFile ; 
?contcontemp = != i8 i8 ?c " " ; 
?contcon = && i8 i8 ?contcon ?contcontemp ; 
label .whilecmp7 ; 
jmpc .while7 ?contcon ; 
++ ?str ; 
def i32 ?type = call idToken ( & ?dstr ) ; 
@ ?__str i64 ?str ; 
def i96 ?tk ; 
subset i32 0 ?tk.type ?tk ; 
subset i64 4 ?tk.__dstr ?tk ; 
call Token@init ( & ?tk ) ; 
call Token@assignDstr ( & ?tk & ?dstr ) ; 
?__tk = & ?tk ; 
end getNextToken ; 
proc getfile ; 
in def i64 ?filename ; 
out def i64 ?__data ; 
begin ; 
def i32 ?fd = call openf ( ?filename ) ; 
def i32 ?filesize = call sizeof_file ( ?fd ) ; 
def i32 ?prot = | i32 i32 1 2 ; 
def i32 ?flags = | i32 i32 2 32 ; 
def i64 ?fileaddr = call mmap ( 0 ?filesize ?prot ?flags 0 0 ) ; 
def i32 ?length = call readf ( ?fd ?fileaddr ?filesize ) ; 
call SYS_closefd ( ?fd ) ; 
def i96 ?data ; 
subset i64 0 ?data.fileaddr ?data ; 
subset i32 8 ?data.filesize ?data ; 
?data.fileaddr = ?fileaddr ; 
?data.filesize = ?filesize ; 
?__data = & ?data ; 
end getfile ; 
proc freefile ; 
in def i64 ?fileaddr ; 
in def i32 ?filesize ; 
begin ; 
call munmap ( ?fileaddr ?filesize ) ; 
end freefile ; 
proc main ; 
begin ; 
static def i144 ?hello = "Hello to Another\n" ; 
call prints ( 1 ?hello ) ; 
static def i104 ?filename = "testfile.alio" ; 
def i64 ?__ofile = call getfile ( ?filename ) ; 
def i96 ?file ; 
subset i64 0 ?file.fileaddr ?file ; 
subset i32 8 ?file.filesize ?file ; 
?file = @ ?__ofile ; 
def i64 ?__file = & ?file ; 
def i64 ?str = ?file.fileaddr ; 
def i64 ?endOfFile = + i64 i32 ?str ?file.filesize ; 
jmp .whilecmp8 ; 
label .while8 ; 
def i64 ?__tk = call getNextToken ( ?endOfFile & ?str ) ; 
def i96 ?tk ; 
subset i32 0 ?tk.type ?tk ; 
subset i64 4 ?tk.__dstr ?tk ; 
?tk = @ ?__tk ; 
call Token@free ( & ?tk ) ; 
label .whilecmp8 ; 
jmpc .while8 < i64 i64 ?str ?endOfFile ; 
call freefile ( ?file.fileaddr ?file.filesize ) ; 
end main ; 
